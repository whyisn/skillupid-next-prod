/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tar-fs";
exports.ids = ["vendor-chunks/tar-fs"];
exports.modules = {

/***/ "(rsc)/./node_modules/tar-fs/index.js":
/*!**************************************!*\
  !*** ./node_modules/tar-fs/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const tar = __webpack_require__(/*! tar-stream */ \"(rsc)/./node_modules/tar-stream/index.js\")\nconst pump = __webpack_require__(/*! pump */ \"(rsc)/./node_modules/pump/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst win32 = (global.Bare ? global.Bare.platform : process.platform) === 'win32'\n\nexports.pack = function pack (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  const xfs = opts.fs || fs\n  const ignore = opts.ignore || opts.filter || noop\n  const mapStream = opts.mapStream || echo\n  const statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)\n  const strict = opts.strict !== false\n  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  const pack = opts.pack || tar.pack()\n  const finish = opts.finish || noop\n\n  let map = opts.map || noop\n  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  onnextentry()\n\n  function onsymlink (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err)\n      header.linkname = normalize(linkname)\n      pack.entry(header, onnextentry)\n    })\n  }\n\n  function onstat (err, filename, stat) {\n    if (pack.destroyed) return\n    if (err) return pack.destroy(err)\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize()\n      return finish(pack)\n    }\n\n    if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n    let header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    }\n\n    if (stat.isDirectory()) {\n      header.size = 0\n      header.type = 'directory'\n      header = map(header) || header\n      return pack.entry(header, onnextentry)\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0\n      header.type = 'symlink'\n      header = map(header) || header\n      return onsymlink(filename, header)\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))\n      return onnextentry()\n    }\n\n    const entry = pack.entry(header, onnextentry)\n    const rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header)\n\n    rs.on('error', function (err) { // always forward errors on destroy\n      entry.destroy(err)\n    })\n\n    pump(rs, entry)\n  }\n\n  function onnextentry (err) {\n    if (err) return pack.destroy(err)\n    statNext(onstat)\n  }\n\n  return pack\n}\n\nfunction head (list) {\n  return list.length ? list[list.length - 1] : null\n}\n\nfunction processGetuid () {\n  return (!global.Bare && process.getuid) ? process.getuid() : -1\n}\n\nfunction processUmask () {\n  return (!global.Bare && process.umask) ? process.umask() : 0\n}\n\nexports.extract = function extract (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  cwd = path.resolve(cwd)\n\n  const xfs = opts.fs || fs\n  const ignore = opts.ignore || opts.filter || noop\n  const mapStream = opts.mapStream || echo\n  const own = opts.chown !== false && !win32 && processGetuid() === 0\n  const extract = opts.extract || tar.extract()\n  const stack = []\n  const now = new Date()\n  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  const strict = opts.strict !== false\n  const validateSymLinks = opts.validateSymlinks !== false\n\n  let map = opts.map || noop\n  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  extract.on('entry', onentry)\n\n  if (opts.finish) extract.on('finish', opts.finish)\n\n  return extract\n\n  function onentry (header, stream, next) {\n    header = map(header) || header\n    header.name = normalize(header.name)\n\n    const name = path.join(cwd, path.join('/', header.name))\n\n    if (ignore(name, header)) {\n      stream.resume()\n      return next()\n    }\n\n    const dir = path.join(name, '.') === path.join(cwd, '.') ? cwd : path.dirname(name)\n\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err)\n      if (!valid) return next(new Error(dir + ' is not a valid path'))\n\n      if (header.type === 'directory') {\n        stack.push([name, header.mtime])\n        return mkdirfix(name, {\n          fs: xfs,\n          own,\n          uid: header.uid,\n          gid: header.gid,\n          mode: header.mode\n        }, stat)\n      }\n\n      mkdirfix(dir, {\n        fs: xfs,\n        own,\n        uid: header.uid,\n        gid: header.gid,\n        // normally, the folders with rights and owner should be part of the TAR file\n        // if this is not the case, create folder for same user as file and with\n        // standard permissions of 0o755 (rwxr-xr-x)\n        mode: 0o755\n      }, function (err) {\n        if (err) return next(err)\n\n        switch (header.type) {\n          case 'file': return onfile()\n          case 'link': return onlink()\n          case 'symlink': return onsymlink()\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))\n\n        stream.resume()\n        next()\n      })\n    })\n\n    function stat (err) {\n      if (err) return next(err)\n      utimes(name, header, function (err) {\n        if (err) return next(err)\n        if (win32) return next()\n        chperm(name, header, next)\n      })\n    }\n\n    function onsymlink () {\n      if (win32) return next() // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        const dst = path.resolve(path.dirname(name), header.linkname)\n        if (!inCwd(dst) && validateSymLinks) return next(new Error(name + ' is not a valid symlink'))\n\n        xfs.symlink(header.linkname, name, stat)\n      })\n    }\n\n    function onlink () {\n      if (win32) return next() // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        const link = path.join(cwd, path.join('/', header.linkname))\n\n        fs.realpath(link, function (err, dst) {\n          if (err || !inCwd(dst)) return next(new Error(name + ' is not a valid hardlink'))\n\n          xfs.link(dst, name, function (err) {\n            if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n              stream = xfs.createReadStream(dst)\n              return onfile()\n            }\n\n            stat(err)\n          })\n        })\n      })\n    }\n\n    function inCwd (dst) {\n      return dst === cwd || dst.startsWith(cwd + path.sep)\n    }\n\n    function onfile () {\n      const ws = xfs.createWriteStream(name)\n      const rs = mapStream(stream, header)\n\n      ws.on('error', function (err) { // always forward errors on destroy\n        rs.destroy(err)\n      })\n\n      pump(rs, ws, function (err) {\n        if (err) return next(err)\n        ws.on('close', stat)\n      })\n    }\n  }\n\n  function utimesParent (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n    let top\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()\n    if (!top) return cb()\n    xfs.utimes(top[0], now, top[1], cb)\n  }\n\n  function utimes (name, header, cb) {\n    if (opts.utimes === false) return cb()\n\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)\n    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err)\n      utimesParent(name, cb)\n    })\n  }\n\n  function chperm (name, header, cb) {\n    const link = header.type === 'symlink'\n\n    /* eslint-disable n/no-deprecated-api */\n    const chmod = link ? xfs.lchmod : xfs.chmod\n    const chown = link ? xfs.lchown : xfs.chown\n    /* eslint-enable n/no-deprecated-api */\n\n    if (!chmod) return cb()\n\n    const mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask\n\n    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown)\n    else onchown(null)\n\n    function onchown (err) {\n      if (err) return cb(err)\n      if (!chmod) return cb()\n      chmod.call(xfs, name, mode, cb)\n    }\n  }\n\n  function mkdirfix (name, opts, cb) {\n    // when mkdir is called on an existing directory, the permissions\n    // will be overwritten (?), to avoid this we check for its existance first\n    xfs.stat(name, function (err) {\n      if (!err) return cb(null)\n      if (err.code !== 'ENOENT') return cb(err)\n      xfs.mkdir(name, { mode: opts.mode, recursive: true }, function (err, made) {\n        if (err) return cb(err)\n        chperm(name, opts, cb)\n      })\n    })\n  }\n}\n\nfunction validate (fs, name, root, cb) {\n  if (name === root) return cb(null, true)\n\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT' && err.code !== 'EPERM') return cb(err)\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)\n    cb(null, false)\n  })\n}\n\nfunction noop () {}\n\nfunction echo (name) {\n  return name\n}\n\nfunction normalize (name) {\n  return win32 ? name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_') : name\n}\n\nfunction statAll (fs, stat, cwd, ignore, entries, sort) {\n  if (!entries) entries = ['.']\n  const queue = entries.slice(0)\n\n  return function loop (callback) {\n    if (!queue.length) return callback(null)\n\n    const next = queue.shift()\n    const nextAbs = path.join(cwd, next)\n\n    stat.call(fs, nextAbs, function (err, stat) {\n      // ignore errors if the files were deleted while buffering\n      if (err) return callback(entries.indexOf(next) === -1 && err.code === 'ENOENT' ? null : err)\n\n      if (!stat.isDirectory()) return callback(null, next, stat)\n\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err)\n\n        if (sort) files.sort()\n\n        for (let i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))\n        }\n\n        callback(null, next, stat)\n      })\n    })\n  }\n}\n\nfunction strip (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/')\n\n    const linkname = header.linkname\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/')\n    }\n\n    return map(header)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGFyLWZzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyw0REFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsZ0RBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsZ0VBQWdFOztBQUUxSSxvQ0FBb0M7QUFDcEM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2tpbGx1cGlkLW5leHQtcHJvZC8uL25vZGVfbW9kdWxlcy90YXItZnMvaW5kZXguanM/N2YzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0YXIgPSByZXF1aXJlKCd0YXItc3RyZWFtJylcbmNvbnN0IHB1bXAgPSByZXF1aXJlKCdwdW1wJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCB3aW4zMiA9IChnbG9iYWwuQmFyZSA/IGdsb2JhbC5CYXJlLnBsYXRmb3JtIDogcHJvY2Vzcy5wbGF0Zm9ybSkgPT09ICd3aW4zMidcblxuZXhwb3J0cy5wYWNrID0gZnVuY3Rpb24gcGFjayAoY3dkLCBvcHRzKSB7XG4gIGlmICghY3dkKSBjd2QgPSAnLidcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBjb25zdCB4ZnMgPSBvcHRzLmZzIHx8IGZzXG4gIGNvbnN0IGlnbm9yZSA9IG9wdHMuaWdub3JlIHx8IG9wdHMuZmlsdGVyIHx8IG5vb3BcbiAgY29uc3QgbWFwU3RyZWFtID0gb3B0cy5tYXBTdHJlYW0gfHwgZWNob1xuICBjb25zdCBzdGF0TmV4dCA9IHN0YXRBbGwoeGZzLCBvcHRzLmRlcmVmZXJlbmNlID8geGZzLnN0YXQgOiB4ZnMubHN0YXQsIGN3ZCwgaWdub3JlLCBvcHRzLmVudHJpZXMsIG9wdHMuc29ydClcbiAgY29uc3Qgc3RyaWN0ID0gb3B0cy5zdHJpY3QgIT09IGZhbHNlXG4gIGNvbnN0IHVtYXNrID0gdHlwZW9mIG9wdHMudW1hc2sgPT09ICdudW1iZXInID8gfm9wdHMudW1hc2sgOiB+cHJvY2Vzc1VtYXNrKClcbiAgY29uc3QgcGFjayA9IG9wdHMucGFjayB8fCB0YXIucGFjaygpXG4gIGNvbnN0IGZpbmlzaCA9IG9wdHMuZmluaXNoIHx8IG5vb3BcblxuICBsZXQgbWFwID0gb3B0cy5tYXAgfHwgbm9vcFxuICBsZXQgZG1vZGUgPSB0eXBlb2Ygb3B0cy5kbW9kZSA9PT0gJ251bWJlcicgPyBvcHRzLmRtb2RlIDogMFxuICBsZXQgZm1vZGUgPSB0eXBlb2Ygb3B0cy5mbW9kZSA9PT0gJ251bWJlcicgPyBvcHRzLmZtb2RlIDogMFxuXG4gIGlmIChvcHRzLnN0cmlwKSBtYXAgPSBzdHJpcChtYXAsIG9wdHMuc3RyaXApXG5cbiAgaWYgKG9wdHMucmVhZGFibGUpIHtcbiAgICBkbW9kZSB8PSBwYXJzZUludCg1NTUsIDgpXG4gICAgZm1vZGUgfD0gcGFyc2VJbnQoNDQ0LCA4KVxuICB9XG4gIGlmIChvcHRzLndyaXRhYmxlKSB7XG4gICAgZG1vZGUgfD0gcGFyc2VJbnQoMzMzLCA4KVxuICAgIGZtb2RlIHw9IHBhcnNlSW50KDIyMiwgOClcbiAgfVxuXG4gIG9ubmV4dGVudHJ5KClcblxuICBmdW5jdGlvbiBvbnN5bWxpbmsgKGZpbGVuYW1lLCBoZWFkZXIpIHtcbiAgICB4ZnMucmVhZGxpbmsocGF0aC5qb2luKGN3ZCwgZmlsZW5hbWUpLCBmdW5jdGlvbiAoZXJyLCBsaW5rbmFtZSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHBhY2suZGVzdHJveShlcnIpXG4gICAgICBoZWFkZXIubGlua25hbWUgPSBub3JtYWxpemUobGlua25hbWUpXG4gICAgICBwYWNrLmVudHJ5KGhlYWRlciwgb25uZXh0ZW50cnkpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uc3RhdCAoZXJyLCBmaWxlbmFtZSwgc3RhdCkge1xuICAgIGlmIChwYWNrLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGVycikgcmV0dXJuIHBhY2suZGVzdHJveShlcnIpXG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgaWYgKG9wdHMuZmluYWxpemUgIT09IGZhbHNlKSBwYWNrLmZpbmFsaXplKClcbiAgICAgIHJldHVybiBmaW5pc2gocGFjaylcbiAgICB9XG5cbiAgICBpZiAoc3RhdC5pc1NvY2tldCgpKSByZXR1cm4gb25uZXh0ZW50cnkoKSAvLyB0YXIgZG9lcyBub3Qgc3VwcG9ydCBzb2NrZXRzLi4uXG5cbiAgICBsZXQgaGVhZGVyID0ge1xuICAgICAgbmFtZTogbm9ybWFsaXplKGZpbGVuYW1lKSxcbiAgICAgIG1vZGU6IChzdGF0Lm1vZGUgfCAoc3RhdC5pc0RpcmVjdG9yeSgpID8gZG1vZGUgOiBmbW9kZSkpICYgdW1hc2ssXG4gICAgICBtdGltZTogc3RhdC5tdGltZSxcbiAgICAgIHNpemU6IHN0YXQuc2l6ZSxcbiAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgIHVpZDogc3RhdC51aWQsXG4gICAgICBnaWQ6IHN0YXQuZ2lkXG4gICAgfVxuXG4gICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaGVhZGVyLnNpemUgPSAwXG4gICAgICBoZWFkZXIudHlwZSA9ICdkaXJlY3RvcnknXG4gICAgICBoZWFkZXIgPSBtYXAoaGVhZGVyKSB8fCBoZWFkZXJcbiAgICAgIHJldHVybiBwYWNrLmVudHJ5KGhlYWRlciwgb25uZXh0ZW50cnkpXG4gICAgfVxuXG4gICAgaWYgKHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgaGVhZGVyLnNpemUgPSAwXG4gICAgICBoZWFkZXIudHlwZSA9ICdzeW1saW5rJ1xuICAgICAgaGVhZGVyID0gbWFwKGhlYWRlcikgfHwgaGVhZGVyXG4gICAgICByZXR1cm4gb25zeW1saW5rKGZpbGVuYW1lLCBoZWFkZXIpXG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIGZpZm8gZXRjLi4uXG5cbiAgICBoZWFkZXIgPSBtYXAoaGVhZGVyKSB8fCBoZWFkZXJcblxuICAgIGlmICghc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIHBhY2suZGVzdHJveShuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGUgZm9yICcgKyBmaWxlbmFtZSkpXG4gICAgICByZXR1cm4gb25uZXh0ZW50cnkoKVxuICAgIH1cblxuICAgIGNvbnN0IGVudHJ5ID0gcGFjay5lbnRyeShoZWFkZXIsIG9ubmV4dGVudHJ5KVxuICAgIGNvbnN0IHJzID0gbWFwU3RyZWFtKHhmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGguam9pbihjd2QsIGZpbGVuYW1lKSwgeyBzdGFydDogMCwgZW5kOiBoZWFkZXIuc2l6ZSA+IDAgPyBoZWFkZXIuc2l6ZSAtIDEgOiBoZWFkZXIuc2l6ZSB9KSwgaGVhZGVyKVxuXG4gICAgcnMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyAvLyBhbHdheXMgZm9yd2FyZCBlcnJvcnMgb24gZGVzdHJveVxuICAgICAgZW50cnkuZGVzdHJveShlcnIpXG4gICAgfSlcblxuICAgIHB1bXAocnMsIGVudHJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gb25uZXh0ZW50cnkgKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBwYWNrLmRlc3Ryb3koZXJyKVxuICAgIHN0YXROZXh0KG9uc3RhdClcbiAgfVxuXG4gIHJldHVybiBwYWNrXG59XG5cbmZ1bmN0aW9uIGhlYWQgKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubGVuZ3RoID8gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdIDogbnVsbFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzR2V0dWlkICgpIHtcbiAgcmV0dXJuICghZ2xvYmFsLkJhcmUgJiYgcHJvY2Vzcy5nZXR1aWQpID8gcHJvY2Vzcy5nZXR1aWQoKSA6IC0xXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVbWFzayAoKSB7XG4gIHJldHVybiAoIWdsb2JhbC5CYXJlICYmIHByb2Nlc3MudW1hc2spID8gcHJvY2Vzcy51bWFzaygpIDogMFxufVxuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiBleHRyYWN0IChjd2QsIG9wdHMpIHtcbiAgaWYgKCFjd2QpIGN3ZCA9ICcuJ1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIGN3ZCA9IHBhdGgucmVzb2x2ZShjd2QpXG5cbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuICBjb25zdCBpZ25vcmUgPSBvcHRzLmlnbm9yZSB8fCBvcHRzLmZpbHRlciB8fCBub29wXG4gIGNvbnN0IG1hcFN0cmVhbSA9IG9wdHMubWFwU3RyZWFtIHx8IGVjaG9cbiAgY29uc3Qgb3duID0gb3B0cy5jaG93biAhPT0gZmFsc2UgJiYgIXdpbjMyICYmIHByb2Nlc3NHZXR1aWQoKSA9PT0gMFxuICBjb25zdCBleHRyYWN0ID0gb3B0cy5leHRyYWN0IHx8IHRhci5leHRyYWN0KClcbiAgY29uc3Qgc3RhY2sgPSBbXVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IHVtYXNrID0gdHlwZW9mIG9wdHMudW1hc2sgPT09ICdudW1iZXInID8gfm9wdHMudW1hc2sgOiB+cHJvY2Vzc1VtYXNrKClcbiAgY29uc3Qgc3RyaWN0ID0gb3B0cy5zdHJpY3QgIT09IGZhbHNlXG4gIGNvbnN0IHZhbGlkYXRlU3ltTGlua3MgPSBvcHRzLnZhbGlkYXRlU3ltbGlua3MgIT09IGZhbHNlXG5cbiAgbGV0IG1hcCA9IG9wdHMubWFwIHx8IG5vb3BcbiAgbGV0IGRtb2RlID0gdHlwZW9mIG9wdHMuZG1vZGUgPT09ICdudW1iZXInID8gb3B0cy5kbW9kZSA6IDBcbiAgbGV0IGZtb2RlID0gdHlwZW9mIG9wdHMuZm1vZGUgPT09ICdudW1iZXInID8gb3B0cy5mbW9kZSA6IDBcblxuICBpZiAob3B0cy5zdHJpcCkgbWFwID0gc3RyaXAobWFwLCBvcHRzLnN0cmlwKVxuXG4gIGlmIChvcHRzLnJlYWRhYmxlKSB7XG4gICAgZG1vZGUgfD0gcGFyc2VJbnQoNTU1LCA4KVxuICAgIGZtb2RlIHw9IHBhcnNlSW50KDQ0NCwgOClcbiAgfVxuICBpZiAob3B0cy53cml0YWJsZSkge1xuICAgIGRtb2RlIHw9IHBhcnNlSW50KDMzMywgOClcbiAgICBmbW9kZSB8PSBwYXJzZUludCgyMjIsIDgpXG4gIH1cblxuICBleHRyYWN0Lm9uKCdlbnRyeScsIG9uZW50cnkpXG5cbiAgaWYgKG9wdHMuZmluaXNoKSBleHRyYWN0Lm9uKCdmaW5pc2gnLCBvcHRzLmZpbmlzaClcblxuICByZXR1cm4gZXh0cmFjdFxuXG4gIGZ1bmN0aW9uIG9uZW50cnkgKGhlYWRlciwgc3RyZWFtLCBuZXh0KSB7XG4gICAgaGVhZGVyID0gbWFwKGhlYWRlcikgfHwgaGVhZGVyXG4gICAgaGVhZGVyLm5hbWUgPSBub3JtYWxpemUoaGVhZGVyLm5hbWUpXG5cbiAgICBjb25zdCBuYW1lID0gcGF0aC5qb2luKGN3ZCwgcGF0aC5qb2luKCcvJywgaGVhZGVyLm5hbWUpKVxuXG4gICAgaWYgKGlnbm9yZShuYW1lLCBoZWFkZXIpKSB7XG4gICAgICBzdHJlYW0ucmVzdW1lKClcbiAgICAgIHJldHVybiBuZXh0KClcbiAgICB9XG5cbiAgICBjb25zdCBkaXIgPSBwYXRoLmpvaW4obmFtZSwgJy4nKSA9PT0gcGF0aC5qb2luKGN3ZCwgJy4nKSA/IGN3ZCA6IHBhdGguZGlybmFtZShuYW1lKVxuXG4gICAgdmFsaWRhdGUoeGZzLCBkaXIsIHBhdGguam9pbihjd2QsICcuJyksIGZ1bmN0aW9uIChlcnIsIHZhbGlkKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICBpZiAoIXZhbGlkKSByZXR1cm4gbmV4dChuZXcgRXJyb3IoZGlyICsgJyBpcyBub3QgYSB2YWxpZCBwYXRoJykpXG5cbiAgICAgIGlmIChoZWFkZXIudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgc3RhY2sucHVzaChbbmFtZSwgaGVhZGVyLm10aW1lXSlcbiAgICAgICAgcmV0dXJuIG1rZGlyZml4KG5hbWUsIHtcbiAgICAgICAgICBmczogeGZzLFxuICAgICAgICAgIG93bixcbiAgICAgICAgICB1aWQ6IGhlYWRlci51aWQsXG4gICAgICAgICAgZ2lkOiBoZWFkZXIuZ2lkLFxuICAgICAgICAgIG1vZGU6IGhlYWRlci5tb2RlXG4gICAgICAgIH0sIHN0YXQpXG4gICAgICB9XG5cbiAgICAgIG1rZGlyZml4KGRpciwge1xuICAgICAgICBmczogeGZzLFxuICAgICAgICBvd24sXG4gICAgICAgIHVpZDogaGVhZGVyLnVpZCxcbiAgICAgICAgZ2lkOiBoZWFkZXIuZ2lkLFxuICAgICAgICAvLyBub3JtYWxseSwgdGhlIGZvbGRlcnMgd2l0aCByaWdodHMgYW5kIG93bmVyIHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBUQVIgZmlsZVxuICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgY3JlYXRlIGZvbGRlciBmb3Igc2FtZSB1c2VyIGFzIGZpbGUgYW5kIHdpdGhcbiAgICAgICAgLy8gc3RhbmRhcmQgcGVybWlzc2lvbnMgb2YgMG83NTUgKHJ3eHIteHIteClcbiAgICAgICAgbW9kZTogMG83NTVcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuXG4gICAgICAgIHN3aXRjaCAoaGVhZGVyLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdmaWxlJzogcmV0dXJuIG9uZmlsZSgpXG4gICAgICAgICAgY2FzZSAnbGluayc6IHJldHVybiBvbmxpbmsoKVxuICAgICAgICAgIGNhc2UgJ3N5bWxpbmsnOiByZXR1cm4gb25zeW1saW5rKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHJldHVybiBuZXh0KG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgdHlwZSBmb3IgJyArIG5hbWUgKyAnICgnICsgaGVhZGVyLnR5cGUgKyAnKScpKVxuXG4gICAgICAgIHN0cmVhbS5yZXN1bWUoKVxuICAgICAgICBuZXh0KClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIHN0YXQgKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKVxuICAgICAgdXRpbWVzKG5hbWUsIGhlYWRlciwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gbmV4dChlcnIpXG4gICAgICAgIGlmICh3aW4zMikgcmV0dXJuIG5leHQoKVxuICAgICAgICBjaHBlcm0obmFtZSwgaGVhZGVyLCBuZXh0KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbnN5bWxpbmsgKCkge1xuICAgICAgaWYgKHdpbjMyKSByZXR1cm4gbmV4dCgpIC8vIHNraXAgc3ltbGlua3Mgb24gd2luIGZvciBub3cgYmVmb3JlIGl0IGNhbiBiZSB0ZXN0ZWRcbiAgICAgIHhmcy51bmxpbmsobmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkc3QgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKG5hbWUpLCBoZWFkZXIubGlua25hbWUpXG4gICAgICAgIGlmICghaW5Dd2QoZHN0KSAmJiB2YWxpZGF0ZVN5bUxpbmtzKSByZXR1cm4gbmV4dChuZXcgRXJyb3IobmFtZSArICcgaXMgbm90IGEgdmFsaWQgc3ltbGluaycpKVxuXG4gICAgICAgIHhmcy5zeW1saW5rKGhlYWRlci5saW5rbmFtZSwgbmFtZSwgc3RhdClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25saW5rICgpIHtcbiAgICAgIGlmICh3aW4zMikgcmV0dXJuIG5leHQoKSAvLyBza2lwIGxpbmtzIG9uIHdpbiBmb3Igbm93IGJlZm9yZSBpdCBjYW4gYmUgdGVzdGVkXG4gICAgICB4ZnMudW5saW5rKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbGluayA9IHBhdGguam9pbihjd2QsIHBhdGguam9pbignLycsIGhlYWRlci5saW5rbmFtZSkpXG5cbiAgICAgICAgZnMucmVhbHBhdGgobGluaywgZnVuY3Rpb24gKGVyciwgZHN0KSB7XG4gICAgICAgICAgaWYgKGVyciB8fCAhaW5Dd2QoZHN0KSkgcmV0dXJuIG5leHQobmV3IEVycm9yKG5hbWUgKyAnIGlzIG5vdCBhIHZhbGlkIGhhcmRsaW5rJykpXG5cbiAgICAgICAgICB4ZnMubGluayhkc3QsIG5hbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdFUEVSTScgJiYgb3B0cy5oYXJkbGlua0FzRmlsZXNGYWxsYmFjaykge1xuICAgICAgICAgICAgICBzdHJlYW0gPSB4ZnMuY3JlYXRlUmVhZFN0cmVhbShkc3QpXG4gICAgICAgICAgICAgIHJldHVybiBvbmZpbGUoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbkN3ZCAoZHN0KSB7XG4gICAgICByZXR1cm4gZHN0ID09PSBjd2QgfHwgZHN0LnN0YXJ0c1dpdGgoY3dkICsgcGF0aC5zZXApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25maWxlICgpIHtcbiAgICAgIGNvbnN0IHdzID0geGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG5hbWUpXG4gICAgICBjb25zdCBycyA9IG1hcFN0cmVhbShzdHJlYW0sIGhlYWRlcilcblxuICAgICAgd3Mub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikgeyAvLyBhbHdheXMgZm9yd2FyZCBlcnJvcnMgb24gZGVzdHJveVxuICAgICAgICBycy5kZXN0cm95KGVycilcbiAgICAgIH0pXG5cbiAgICAgIHB1bXAocnMsIHdzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycilcbiAgICAgICAgd3Mub24oJ2Nsb3NlJywgc3RhdClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXRpbWVzUGFyZW50IChuYW1lLCBjYikgeyAvLyB3ZSBqdXN0IHNldCB0aGUgbXRpbWUgb24gdGhlIHBhcmVudCBkaXIgYWdhaW4gZXZlcnl0aW1lIHdlIHdyaXRlIGFuIGVudHJ5XG4gICAgbGV0IHRvcFxuICAgIHdoaWxlICgodG9wID0gaGVhZChzdGFjaykpICYmIG5hbWUuc2xpY2UoMCwgdG9wWzBdLmxlbmd0aCkgIT09IHRvcFswXSkgc3RhY2sucG9wKClcbiAgICBpZiAoIXRvcCkgcmV0dXJuIGNiKClcbiAgICB4ZnMudXRpbWVzKHRvcFswXSwgbm93LCB0b3BbMV0sIGNiKVxuICB9XG5cbiAgZnVuY3Rpb24gdXRpbWVzIChuYW1lLCBoZWFkZXIsIGNiKSB7XG4gICAgaWYgKG9wdHMudXRpbWVzID09PSBmYWxzZSkgcmV0dXJuIGNiKClcblxuICAgIGlmIChoZWFkZXIudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHJldHVybiB4ZnMudXRpbWVzKG5hbWUsIG5vdywgaGVhZGVyLm10aW1lLCBjYilcbiAgICBpZiAoaGVhZGVyLnR5cGUgPT09ICdzeW1saW5rJykgcmV0dXJuIHV0aW1lc1BhcmVudChuYW1lLCBjYikgLy8gVE9ETzogaG93IHRvIHNldCBtdGltZSBvbiBsaW5rP1xuXG4gICAgeGZzLnV0aW1lcyhuYW1lLCBub3csIGhlYWRlci5tdGltZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHV0aW1lc1BhcmVudChuYW1lLCBjYilcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY2hwZXJtIChuYW1lLCBoZWFkZXIsIGNiKSB7XG4gICAgY29uc3QgbGluayA9IGhlYWRlci50eXBlID09PSAnc3ltbGluaydcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG4vbm8tZGVwcmVjYXRlZC1hcGkgKi9cbiAgICBjb25zdCBjaG1vZCA9IGxpbmsgPyB4ZnMubGNobW9kIDogeGZzLmNobW9kXG4gICAgY29uc3QgY2hvd24gPSBsaW5rID8geGZzLmxjaG93biA6IHhmcy5jaG93blxuICAgIC8qIGVzbGludC1lbmFibGUgbi9uby1kZXByZWNhdGVkLWFwaSAqL1xuXG4gICAgaWYgKCFjaG1vZCkgcmV0dXJuIGNiKClcblxuICAgIGNvbnN0IG1vZGUgPSAoaGVhZGVyLm1vZGUgfCAoaGVhZGVyLnR5cGUgPT09ICdkaXJlY3RvcnknID8gZG1vZGUgOiBmbW9kZSkpICYgdW1hc2tcblxuICAgIGlmIChjaG93biAmJiBvd24pIGNob3duLmNhbGwoeGZzLCBuYW1lLCBoZWFkZXIudWlkLCBoZWFkZXIuZ2lkLCBvbmNob3duKVxuICAgIGVsc2Ugb25jaG93bihudWxsKVxuXG4gICAgZnVuY3Rpb24gb25jaG93biAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKCFjaG1vZCkgcmV0dXJuIGNiKClcbiAgICAgIGNobW9kLmNhbGwoeGZzLCBuYW1lLCBtb2RlLCBjYilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBta2RpcmZpeCAobmFtZSwgb3B0cywgY2IpIHtcbiAgICAvLyB3aGVuIG1rZGlyIGlzIGNhbGxlZCBvbiBhbiBleGlzdGluZyBkaXJlY3RvcnksIHRoZSBwZXJtaXNzaW9uc1xuICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gKD8pLCB0byBhdm9pZCB0aGlzIHdlIGNoZWNrIGZvciBpdHMgZXhpc3RhbmNlIGZpcnN0XG4gICAgeGZzLnN0YXQobmFtZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnIpIHJldHVybiBjYihudWxsKVxuICAgICAgaWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykgcmV0dXJuIGNiKGVycilcbiAgICAgIHhmcy5ta2RpcihuYW1lLCB7IG1vZGU6IG9wdHMubW9kZSwgcmVjdXJzaXZlOiB0cnVlIH0sIGZ1bmN0aW9uIChlcnIsIG1hZGUpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgY2hwZXJtKG5hbWUsIG9wdHMsIGNiKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlIChmcywgbmFtZSwgcm9vdCwgY2IpIHtcbiAgaWYgKG5hbWUgPT09IHJvb3QpIHJldHVybiBjYihudWxsLCB0cnVlKVxuXG4gIGZzLmxzdGF0KG5hbWUsIGZ1bmN0aW9uIChlcnIsIHN0KSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VOT0VOVCcgJiYgZXJyLmNvZGUgIT09ICdFUEVSTScpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGVyciB8fCBzdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gdmFsaWRhdGUoZnMsIHBhdGguam9pbihuYW1lLCAnLi4nKSwgcm9vdCwgY2IpXG4gICAgY2IobnVsbCwgZmFsc2UpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gZWNobyAobmFtZSkge1xuICByZXR1cm4gbmFtZVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemUgKG5hbWUpIHtcbiAgcmV0dXJuIHdpbjMyID8gbmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvWzo/PD58XS9nLCAnXycpIDogbmFtZVxufVxuXG5mdW5jdGlvbiBzdGF0QWxsIChmcywgc3RhdCwgY3dkLCBpZ25vcmUsIGVudHJpZXMsIHNvcnQpIHtcbiAgaWYgKCFlbnRyaWVzKSBlbnRyaWVzID0gWycuJ11cbiAgY29uc3QgcXVldWUgPSBlbnRyaWVzLnNsaWNlKDApXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGxvb3AgKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsKVxuXG4gICAgY29uc3QgbmV4dCA9IHF1ZXVlLnNoaWZ0KClcbiAgICBjb25zdCBuZXh0QWJzID0gcGF0aC5qb2luKGN3ZCwgbmV4dClcblxuICAgIHN0YXQuY2FsbChmcywgbmV4dEFicywgZnVuY3Rpb24gKGVyciwgc3RhdCkge1xuICAgICAgLy8gaWdub3JlIGVycm9ycyBpZiB0aGUgZmlsZXMgd2VyZSBkZWxldGVkIHdoaWxlIGJ1ZmZlcmluZ1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVudHJpZXMuaW5kZXhPZihuZXh0KSA9PT0gLTEgJiYgZXJyLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVycilcblxuICAgICAgaWYgKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXh0LCBzdGF0KVxuXG4gICAgICBmcy5yZWFkZGlyKG5leHRBYnMsIGZ1bmN0aW9uIChlcnIsIGZpbGVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICAgICAgaWYgKHNvcnQpIGZpbGVzLnNvcnQoKVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWlnbm9yZShwYXRoLmpvaW4oY3dkLCBuZXh0LCBmaWxlc1tpXSkpKSBxdWV1ZS5wdXNoKHBhdGguam9pbihuZXh0LCBmaWxlc1tpXSkpXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBuZXh0LCBzdGF0KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwIChtYXAsIGxldmVsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgaGVhZGVyLm5hbWUgPSBoZWFkZXIubmFtZS5zcGxpdCgnLycpLnNsaWNlKGxldmVsKS5qb2luKCcvJylcblxuICAgIGNvbnN0IGxpbmtuYW1lID0gaGVhZGVyLmxpbmtuYW1lXG4gICAgaWYgKGxpbmtuYW1lICYmIChoZWFkZXIudHlwZSA9PT0gJ2xpbmsnIHx8IHBhdGguaXNBYnNvbHV0ZShsaW5rbmFtZSkpKSB7XG4gICAgICBoZWFkZXIubGlua25hbWUgPSBsaW5rbmFtZS5zcGxpdCgnLycpLnNsaWNlKGxldmVsKS5qb2luKCcvJylcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwKGhlYWRlcilcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tar-fs/index.js\n");

/***/ })

};
;