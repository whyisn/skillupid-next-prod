/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/streamx";
exports.ids = ["vendor-chunks/streamx"];
exports.modules = {

/***/ "(rsc)/./node_modules/streamx/index.js":
/*!***************************************!*\
  !*** ./node_modules/streamx/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { EventEmitter } = __webpack_require__(/*! events-universal */ \"(rsc)/./node_modules/events-universal/default.js\")\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = __webpack_require__(/*! fast-fifo */ \"(rsc)/./node_modules/fast-fifo/index.js\")\nconst TextDecoder = __webpack_require__(/*! text-decoder */ \"(rsc)/./node_modules/text-decoder/index.js\")\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3RyZWFteC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDBFQUFrQjtBQUNuRDtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwREFBVztBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYzs7QUFFMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsaUZBQWlGLElBQUk7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGlGQUFpRixJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw4QkFBOEI7QUFDNUY7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEI7QUFDdkQsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NraWxsdXBpZC1uZXh0LXByb2QvLi9ub2RlX21vZHVsZXMvc3RyZWFteC9pbmRleC5qcz9mMzM5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMtdW5pdmVyc2FsJylcbmNvbnN0IFNUUkVBTV9ERVNUUk9ZRUQgPSBuZXcgRXJyb3IoJ1N0cmVhbSB3YXMgZGVzdHJveWVkJylcbmNvbnN0IFBSRU1BVFVSRV9DTE9TRSA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJylcblxuY29uc3QgRklGTyA9IHJlcXVpcmUoJ2Zhc3QtZmlmbycpXG5jb25zdCBUZXh0RGVjb2RlciA9IHJlcXVpcmUoJ3RleHQtZGVjb2RlcicpXG5cbi8vIGlmIHdlIGRvIGEgZnV0dXJlIG1ham9yLCBleHBlY3QgcXVldWUgbWljcm90YXNrIHRvIGJlIHRoZXJlIGFsd2F5cywgZm9yIG5vdyBhIGJpdCBkZWZlbnNpdmVcbmNvbnN0IHFtdCA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ3VuZGVmaW5lZCcgPyBmbiA9PiBnbG9iYWwucHJvY2Vzcy5uZXh0VGljayhmbikgOiBxdWV1ZU1pY3JvdGFza1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1tdWx0aS1zcGFjZXMgKi9cblxuLy8gMjkgYml0cyB1c2VkIHRvdGFsICg0IGZyb20gc2hhcmVkLCAxNCBmcm9tIHJlYWQsIGFuZCAxMSBmcm9tIHdyaXRlKVxuY29uc3QgTUFYID0gKCgxIDw8IDI5KSAtIDEpXG5cbi8vIFNoYXJlZCBzdGF0ZVxuY29uc3QgT1BFTklORyAgICAgICA9IDBiMDAwMVxuY29uc3QgUFJFREVTVFJPWUlORyA9IDBiMDAxMFxuY29uc3QgREVTVFJPWUlORyAgICA9IDBiMDEwMFxuY29uc3QgREVTVFJPWUVEICAgICA9IDBiMTAwMFxuXG5jb25zdCBOT1RfT1BFTklORyA9IE1BWCBeIE9QRU5JTkdcbmNvbnN0IE5PVF9QUkVERVNUUk9ZSU5HID0gTUFYIF4gUFJFREVTVFJPWUlOR1xuXG4vLyBSZWFkIHN0YXRlICg0IGJpdCBvZmZzZXQgZnJvbSBzaGFyZWQgc3RhdGUpXG5jb25zdCBSRUFEX0FDVElWRSAgICAgICAgICAgPSAwYjAwMDAwMDAwMDAwMDAxIDw8IDRcbmNvbnN0IFJFQURfVVBEQVRJTkcgICAgICAgICA9IDBiMDAwMDAwMDAwMDAwMTAgPDwgNFxuY29uc3QgUkVBRF9QUklNQVJZICAgICAgICAgID0gMGIwMDAwMDAwMDAwMDEwMCA8PCA0XG5jb25zdCBSRUFEX1FVRVVFRCAgICAgICAgICAgPSAwYjAwMDAwMDAwMDAxMDAwIDw8IDRcbmNvbnN0IFJFQURfUkVTVU1FRCAgICAgICAgICA9IDBiMDAwMDAwMDAwMTAwMDAgPDwgNFxuY29uc3QgUkVBRF9QSVBFX0RSQUlORUQgICAgID0gMGIwMDAwMDAwMDEwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0VORElORyAgICAgICAgICAgPSAwYjAwMDAwMDAxMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfRU1JVF9EQVRBICAgICAgICA9IDBiMDAwMDAwMTAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9FTUlUX1JFQURBQkxFICAgID0gMGIwMDAwMDEwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX0VNSVRURURfUkVBREFCTEUgPSAwYjAwMDAxMDAwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfRE9ORSAgICAgICAgICAgICA9IDBiMDAwMTAwMDAwMDAwMDAgPDwgNFxuY29uc3QgUkVBRF9ORVhUX1RJQ0sgICAgICAgID0gMGIwMDEwMDAwMDAwMDAwMCA8PCA0XG5jb25zdCBSRUFEX05FRURTX1BVU0ggICAgICAgPSAwYjAxMDAwMDAwMDAwMDAwIDw8IDRcbmNvbnN0IFJFQURfUkVBRF9BSEVBRCAgICAgICA9IDBiMTAwMDAwMDAwMDAwMDAgPDwgNFxuXG4vLyBDb21iaW5lZCByZWFkIHN0YXRlXG5jb25zdCBSRUFEX0ZMT1dJTkcgPSBSRUFEX1JFU1VNRUQgfCBSRUFEX1BJUEVfRFJBSU5FRFxuY29uc3QgUkVBRF9BQ1RJVkVfQU5EX05FRURTX1BVU0ggPSBSRUFEX0FDVElWRSB8IFJFQURfTkVFRFNfUFVTSFxuY29uc3QgUkVBRF9QUklNQVJZX0FORF9BQ1RJVkUgPSBSRUFEX1BSSU1BUlkgfCBSRUFEX0FDVElWRVxuY29uc3QgUkVBRF9FTUlUX1JFQURBQkxFX0FORF9RVUVVRUQgPSBSRUFEX0VNSVRfUkVBREFCTEUgfCBSRUFEX1FVRVVFRFxuY29uc3QgUkVBRF9SRVNVTUVEX1JFQURfQUhFQUQgPSBSRUFEX1JFU1VNRUQgfCBSRUFEX1JFQURfQUhFQURcblxuY29uc3QgUkVBRF9OT1RfQUNUSVZFICAgICAgICAgICAgID0gTUFYIF4gUkVBRF9BQ1RJVkVcbmNvbnN0IFJFQURfTk9OX1BSSU1BUlkgICAgICAgICAgICA9IE1BWCBeIFJFQURfUFJJTUFSWVxuY29uc3QgUkVBRF9OT05fUFJJTUFSWV9BTkRfUFVTSEVEID0gTUFYIF4gKFJFQURfUFJJTUFSWSB8IFJFQURfTkVFRFNfUFVTSClcbmNvbnN0IFJFQURfUFVTSEVEICAgICAgICAgICAgICAgICA9IE1BWCBeIFJFQURfTkVFRFNfUFVTSFxuY29uc3QgUkVBRF9QQVVTRUQgICAgICAgICAgICAgICAgID0gTUFYIF4gUkVBRF9SRVNVTUVEXG5jb25zdCBSRUFEX05PVF9RVUVVRUQgICAgICAgICAgICAgPSBNQVggXiAoUkVBRF9RVUVVRUQgfCBSRUFEX0VNSVRURURfUkVBREFCTEUpXG5jb25zdCBSRUFEX05PVF9FTkRJTkcgICAgICAgICAgICAgPSBNQVggXiBSRUFEX0VORElOR1xuY29uc3QgUkVBRF9QSVBFX05PVF9EUkFJTkVEICAgICAgID0gTUFYIF4gUkVBRF9GTE9XSU5HXG5jb25zdCBSRUFEX05PVF9ORVhUX1RJQ0sgICAgICAgICAgPSBNQVggXiBSRUFEX05FWFRfVElDS1xuY29uc3QgUkVBRF9OT1RfVVBEQVRJTkcgICAgICAgICAgID0gTUFYIF4gUkVBRF9VUERBVElOR1xuY29uc3QgUkVBRF9OT19SRUFEX0FIRUFEICAgICAgICAgID0gTUFYIF4gUkVBRF9SRUFEX0FIRUFEXG5jb25zdCBSRUFEX1BBVVNFRF9OT19SRUFEX0FIRUFEICAgPSBNQVggXiBSRUFEX1JFU1VNRURfUkVBRF9BSEVBRFxuXG4vLyBXcml0ZSBzdGF0ZSAoMTggYml0IG9mZnNldCwgNCBiaXQgb2Zmc2V0IGZyb20gc2hhcmVkIHN0YXRlIGFuZCAxNCBmcm9tIHJlYWQgc3RhdGUpXG5jb25zdCBXUklURV9BQ1RJVkUgICAgID0gMGIwMDAwMDAwMDAwMSA8PCAxOFxuY29uc3QgV1JJVEVfVVBEQVRJTkcgICA9IDBiMDAwMDAwMDAwMTAgPDwgMThcbmNvbnN0IFdSSVRFX1BSSU1BUlkgICAgPSAwYjAwMDAwMDAwMTAwIDw8IDE4XG5jb25zdCBXUklURV9RVUVVRUQgICAgID0gMGIwMDAwMDAwMTAwMCA8PCAxOFxuY29uc3QgV1JJVEVfVU5EUkFJTkVEICA9IDBiMDAwMDAwMTAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX0RPTkUgICAgICAgPSAwYjAwMDAwMTAwMDAwIDw8IDE4XG5jb25zdCBXUklURV9FTUlUX0RSQUlOID0gMGIwMDAwMTAwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfTkVYVF9USUNLICA9IDBiMDAwMTAwMDAwMDAgPDwgMThcbmNvbnN0IFdSSVRFX1dSSVRJTkcgICAgPSAwYjAwMTAwMDAwMDAwIDw8IDE4XG5jb25zdCBXUklURV9GSU5JU0hJTkcgID0gMGIwMTAwMDAwMDAwMCA8PCAxOFxuY29uc3QgV1JJVEVfQ09SS0VEICAgICA9IDBiMTAwMDAwMDAwMDAgPDwgMThcblxuY29uc3QgV1JJVEVfTk9UX0FDVElWRSAgICA9IE1BWCBeIChXUklURV9BQ1RJVkUgfCBXUklURV9XUklUSU5HKVxuY29uc3QgV1JJVEVfTk9OX1BSSU1BUlkgICA9IE1BWCBeIFdSSVRFX1BSSU1BUllcbmNvbnN0IFdSSVRFX05PVF9GSU5JU0hJTkcgPSBNQVggXiAoV1JJVEVfQUNUSVZFIHwgV1JJVEVfRklOSVNISU5HKVxuY29uc3QgV1JJVEVfRFJBSU5FRCAgICAgICA9IE1BWCBeIFdSSVRFX1VORFJBSU5FRFxuY29uc3QgV1JJVEVfTk9UX1FVRVVFRCAgICA9IE1BWCBeIFdSSVRFX1FVRVVFRFxuY29uc3QgV1JJVEVfTk9UX05FWFRfVElDSyA9IE1BWCBeIFdSSVRFX05FWFRfVElDS1xuY29uc3QgV1JJVEVfTk9UX1VQREFUSU5HICA9IE1BWCBeIFdSSVRFX1VQREFUSU5HXG5jb25zdCBXUklURV9OT1RfQ09SS0VEICAgID0gTUFYIF4gV1JJVEVfQ09SS0VEXG5cbi8vIENvbWJpbmVkIHNoYXJlZCBzdGF0ZVxuY29uc3QgQUNUSVZFID0gUkVBRF9BQ1RJVkUgfCBXUklURV9BQ1RJVkVcbmNvbnN0IE5PVF9BQ1RJVkUgPSBNQVggXiBBQ1RJVkVcbmNvbnN0IERPTkUgPSBSRUFEX0RPTkUgfCBXUklURV9ET05FXG5jb25zdCBERVNUUk9ZX1NUQVRVUyA9IERFU1RST1lJTkcgfCBERVNUUk9ZRUQgfCBQUkVERVNUUk9ZSU5HXG5jb25zdCBPUEVOX1NUQVRVUyA9IERFU1RST1lfU1RBVFVTIHwgT1BFTklOR1xuY29uc3QgQVVUT19ERVNUUk9ZID0gREVTVFJPWV9TVEFUVVMgfCBET05FXG5jb25zdCBOT05fUFJJTUFSWSA9IFdSSVRFX05PTl9QUklNQVJZICYgUkVBRF9OT05fUFJJTUFSWVxuY29uc3QgQUNUSVZFX09SX1RJQ0tJTkcgPSBXUklURV9ORVhUX1RJQ0sgfCBSRUFEX05FWFRfVElDS1xuY29uc3QgVElDS0lORyA9IEFDVElWRV9PUl9USUNLSU5HICYgTk9UX0FDVElWRVxuY29uc3QgSVNfT1BFTklORyA9IE9QRU5fU1RBVFVTIHwgVElDS0lOR1xuXG4vLyBDb21iaW5lZCBzaGFyZWQgc3RhdGUgYW5kIHJlYWQgc3RhdGVcbmNvbnN0IFJFQURfUFJJTUFSWV9TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFJFQURfRU5ESU5HIHwgUkVBRF9ET05FXG5jb25zdCBSRUFEX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgUkVBRF9ET05FIHwgUkVBRF9RVUVVRURcbmNvbnN0IFJFQURfRU5ESU5HX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgUkVBRF9FTkRJTkcgfCBSRUFEX1FVRVVFRFxuY29uc3QgUkVBRF9SRUFEQUJMRV9TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFJFQURfRU1JVF9SRUFEQUJMRSB8IFJFQURfUVVFVUVEIHwgUkVBRF9FTUlUVEVEX1JFQURBQkxFXG5jb25zdCBTSE9VTERfTk9UX1JFQUQgPSBPUEVOX1NUQVRVUyB8IFJFQURfQUNUSVZFIHwgUkVBRF9FTkRJTkcgfCBSRUFEX0RPTkUgfCBSRUFEX05FRURTX1BVU0ggfCBSRUFEX1JFQURfQUhFQURcbmNvbnN0IFJFQURfQkFDS1BSRVNTVVJFX1NUQVRVUyA9IERFU1RST1lfU1RBVFVTIHwgUkVBRF9FTkRJTkcgfCBSRUFEX0RPTkVcbmNvbnN0IFJFQURfVVBEQVRFX1NZTkNfU1RBVFVTID0gUkVBRF9VUERBVElORyB8IE9QRU5fU1RBVFVTIHwgUkVBRF9ORVhUX1RJQ0sgfCBSRUFEX1BSSU1BUllcbmNvbnN0IFJFQURfTkVYVF9USUNLX09SX09QRU5JTkcgPSBSRUFEX05FWFRfVElDSyB8IE9QRU5JTkdcblxuLy8gQ29tYmluZWQgd3JpdGUgc3RhdGVcbmNvbnN0IFdSSVRFX1BSSU1BUllfU1RBVFVTID0gT1BFTl9TVEFUVVMgfCBXUklURV9GSU5JU0hJTkcgfCBXUklURV9ET05FXG5jb25zdCBXUklURV9RVUVVRURfQU5EX1VORFJBSU5FRCA9IFdSSVRFX1FVRVVFRCB8IFdSSVRFX1VORFJBSU5FRFxuY29uc3QgV1JJVEVfUVVFVUVEX0FORF9BQ1RJVkUgPSBXUklURV9RVUVVRUQgfCBXUklURV9BQ1RJVkVcbmNvbnN0IFdSSVRFX0RSQUlOX1NUQVRVUyA9IFdSSVRFX1FVRVVFRCB8IFdSSVRFX1VORFJBSU5FRCB8IE9QRU5fU1RBVFVTIHwgV1JJVEVfQUNUSVZFXG5jb25zdCBXUklURV9TVEFUVVMgPSBPUEVOX1NUQVRVUyB8IFdSSVRFX0FDVElWRSB8IFdSSVRFX1FVRVVFRCB8IFdSSVRFX0NPUktFRFxuY29uc3QgV1JJVEVfUFJJTUFSWV9BTkRfQUNUSVZFID0gV1JJVEVfUFJJTUFSWSB8IFdSSVRFX0FDVElWRVxuY29uc3QgV1JJVEVfQUNUSVZFX0FORF9XUklUSU5HID0gV1JJVEVfQUNUSVZFIHwgV1JJVEVfV1JJVElOR1xuY29uc3QgV1JJVEVfRklOSVNISU5HX1NUQVRVUyA9IE9QRU5fU1RBVFVTIHwgV1JJVEVfRklOSVNISU5HIHwgV1JJVEVfUVVFVUVEX0FORF9BQ1RJVkUgfCBXUklURV9ET05FXG5jb25zdCBXUklURV9CQUNLUFJFU1NVUkVfU1RBVFVTID0gV1JJVEVfVU5EUkFJTkVEIHwgREVTVFJPWV9TVEFUVVMgfCBXUklURV9GSU5JU0hJTkcgfCBXUklURV9ET05FXG5jb25zdCBXUklURV9VUERBVEVfU1lOQ19TVEFUVVMgPSBXUklURV9VUERBVElORyB8IE9QRU5fU1RBVFVTIHwgV1JJVEVfTkVYVF9USUNLIHwgV1JJVEVfUFJJTUFSWVxuY29uc3QgV1JJVEVfRFJPUF9EQVRBID0gV1JJVEVfRklOSVNISU5HIHwgV1JJVEVfRE9ORSB8IERFU1RST1lfU1RBVFVTXG5cbmNvbnN0IGFzeW5jSXRlcmF0b3IgPSBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBTeW1ib2woJ2FzeW5jSXRlcmF0b3InKVxuXG5jbGFzcyBXcml0YWJsZVN0YXRlIHtcbiAgY29uc3RydWN0b3IgKHN0cmVhbSwgeyBoaWdoV2F0ZXJNYXJrID0gMTYzODQsIG1hcCA9IG51bGwsIG1hcFdyaXRhYmxlLCBieXRlTGVuZ3RoLCBieXRlTGVuZ3RoV3JpdGFibGUgfSA9IHt9KSB7XG4gICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cbiAgICB0aGlzLnF1ZXVlID0gbmV3IEZJRk8oKVxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcmtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gMFxuICAgIHRoaXMuZXJyb3IgPSBudWxsXG4gICAgdGhpcy5waXBlbGluZSA9IG51bGxcbiAgICB0aGlzLmRyYWlucyA9IG51bGwgLy8gaWYgd2UgYWRkIG1vcmUgc2VsZG9tbHkgdXNlZCBoZWxwZXJzIHdlIG1pZ2h0IHRoZW0gaW50byBhIHN1Ym9iamVjdCBzbyBpdHMgYSBzaW5nbGUgcHRyXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFdyaXRhYmxlIHx8IGJ5dGVMZW5ndGggfHwgZGVmYXVsdEJ5dGVMZW5ndGhcbiAgICB0aGlzLm1hcCA9IG1hcFdyaXRhYmxlIHx8IG1hcFxuICAgIHRoaXMuYWZ0ZXJXcml0ZSA9IGFmdGVyV3JpdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuYWZ0ZXJVcGRhdGVOZXh0VGljayA9IHVwZGF0ZVdyaXRlTlQuYmluZCh0aGlzKVxuICB9XG5cbiAgZ2V0IGVuZGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX0RPTkUpICE9PSAwXG4gIH1cblxuICBwdXNoIChkYXRhKSB7XG4gICAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9EUk9QX0RBVEEpICE9PSAwKSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGhpcy5tYXAgIT09IG51bGwpIGRhdGEgPSB0aGlzLm1hcChkYXRhKVxuXG4gICAgdGhpcy5idWZmZXJlZCArPSB0aGlzLmJ5dGVMZW5ndGgoZGF0YSlcbiAgICB0aGlzLnF1ZXVlLnB1c2goZGF0YSlcblxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkIDwgdGhpcy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfUVVFVUVEXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9RVUVVRURfQU5EX1VORFJBSU5FRFxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc2hpZnQgKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnF1ZXVlLnNoaWZ0KClcblxuICAgIHRoaXMuYnVmZmVyZWQgLT0gdGhpcy5ieXRlTGVuZ3RoKGRhdGEpXG4gICAgaWYgKHRoaXMuYnVmZmVyZWQgPT09IDApIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfUVVFVUVEXG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZW5kIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB0aGlzLnN0cmVhbS5vbmNlKCdmaW5pc2gnLCBkYXRhKVxuICAgIGVsc2UgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB0aGlzLnB1c2goZGF0YSlcbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgPSAodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHwgV1JJVEVfRklOSVNISU5HKSAmIFdSSVRFX05PTl9QUklNQVJZXG4gIH1cblxuICBhdXRvQmF0Y2ggKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW11cbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICB3aGlsZSAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9TVEFUVVMpID09PSBXUklURV9RVUVVRURfQU5EX0FDVElWRSkge1xuICAgICAgYnVmZmVyLnB1c2goc3RyZWFtLl93cml0YWJsZVN0YXRlLnNoaWZ0KCkpXG4gICAgfVxuXG4gICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgT1BFTl9TVEFUVVMpICE9PSAwKSByZXR1cm4gY2IobnVsbClcbiAgICBzdHJlYW0uX3dyaXRldihidWZmZXIsIGNiKVxuICB9XG5cbiAgdXBkYXRlICgpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnN0cmVhbVxuXG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9VUERBVElOR1xuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfU1RBVFVTKSA9PT0gV1JJVEVfUVVFVUVEKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNoaWZ0KClcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9BQ1RJVkVfQU5EX1dSSVRJTkdcbiAgICAgICAgc3RyZWFtLl93cml0ZShkYXRhLCB0aGlzLmFmdGVyV3JpdGUpXG4gICAgICB9XG5cbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFdSSVRFX1BSSU1BUllfQU5EX0FDVElWRSkgPT09IDApIHRoaXMudXBkYXRlTm9uUHJpbWFyeSgpXG4gICAgfSB3aGlsZSAodGhpcy5jb250aW51ZVVwZGF0ZSgpID09PSB0cnVlKVxuXG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfVVBEQVRJTkdcbiAgfVxuXG4gIHVwZGF0ZU5vblByaW1hcnkgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9GSU5JU0hJTkdfU1RBVFVTKSA9PT0gV1JJVEVfRklOSVNISU5HKSB7XG4gICAgICBzdHJlYW0uX2R1cGxleFN0YXRlID0gc3RyZWFtLl9kdXBsZXhTdGF0ZSB8IFdSSVRFX0FDVElWRVxuICAgICAgc3RyZWFtLl9maW5hbChhZnRlckZpbmFsLmJpbmQodGhpcykpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZX1NUQVRVUykgPT09IERFU1RST1lJTkcpIHtcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFDVElWRV9PUl9USUNLSU5HKSA9PT0gMCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IEFDVElWRVxuICAgICAgICBzdHJlYW0uX2Rlc3Ryb3koYWZ0ZXJEZXN0cm95LmJpbmQodGhpcykpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBJU19PUEVOSU5HKSA9PT0gT1BFTklORykge1xuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgQUNUSVZFKSAmIE5PVF9PUEVOSU5HXG4gICAgICBzdHJlYW0uX29wZW4oYWZ0ZXJPcGVuLmJpbmQodGhpcykpXG4gICAgfVxuICB9XG5cbiAgY29udGludWVVcGRhdGUgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfTkVYVF9USUNLKSA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9ORVhUX1RJQ0tcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdXBkYXRlQ2FsbGJhY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRFX1NZTkNfU1RBVFVTKSA9PT0gV1JJVEVfUFJJTUFSWSkgdGhpcy51cGRhdGUoKVxuICAgIGVsc2UgdGhpcy51cGRhdGVOZXh0VGljaygpXG4gIH1cblxuICB1cGRhdGVOZXh0VGljayAoKSB7XG4gICAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9ORVhUX1RJQ0spICE9PSAwKSByZXR1cm5cbiAgICB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfTkVYVF9USUNLXG4gICAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9VUERBVElORykgPT09IDApIHFtdCh0aGlzLmFmdGVyVXBkYXRlTmV4dFRpY2spXG4gIH1cbn1cblxuY2xhc3MgUmVhZGFibGVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yIChzdHJlYW0sIHsgaGlnaFdhdGVyTWFyayA9IDE2Mzg0LCBtYXAgPSBudWxsLCBtYXBSZWFkYWJsZSwgYnl0ZUxlbmd0aCwgYnl0ZUxlbmd0aFJlYWRhYmxlIH0gPSB7fSkge1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtXG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBGSUZPKClcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrID09PSAwID8gMSA6IGhpZ2hXYXRlck1hcmtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gMFxuICAgIHRoaXMucmVhZEFoZWFkID0gaGlnaFdhdGVyTWFyayA+IDBcbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMucGlwZWxpbmUgPSBudWxsXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFJlYWRhYmxlIHx8IGJ5dGVMZW5ndGggfHwgZGVmYXVsdEJ5dGVMZW5ndGhcbiAgICB0aGlzLm1hcCA9IG1hcFJlYWRhYmxlIHx8IG1hcFxuICAgIHRoaXMucGlwZVRvID0gbnVsbFxuICAgIHRoaXMuYWZ0ZXJSZWFkID0gYWZ0ZXJSZWFkLmJpbmQodGhpcylcbiAgICB0aGlzLmFmdGVyVXBkYXRlTmV4dFRpY2sgPSB1cGRhdGVSZWFkTlQuYmluZCh0aGlzKVxuICB9XG5cbiAgZ2V0IGVuZGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRE9ORSkgIT09IDBcbiAgfVxuXG4gIHBpcGUgKHBpcGVUbywgY2IpIHtcbiAgICBpZiAodGhpcy5waXBlVG8gIT09IG51bGwpIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgcGlwZSB0byBvbmUgZGVzdGluYXRpb24nKVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbnVsbFxuXG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfUElQRV9EUkFJTkVEXG4gICAgdGhpcy5waXBlVG8gPSBwaXBlVG9cbiAgICB0aGlzLnBpcGVsaW5lID0gbmV3IFBpcGVsaW5lKHRoaXMuc3RyZWFtLCBwaXBlVG8sIGNiKVxuXG4gICAgaWYgKGNiKSB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBub29wKSAvLyBXZSBhbHJlYWR5IGVycm9yIGhhbmRsZSB0aGlzIHNvIHN1cHJlc3MgY3Jhc2hlc1xuXG4gICAgaWYgKGlzU3RyZWFteChwaXBlVG8pKSB7XG4gICAgICBwaXBlVG8uX3dyaXRhYmxlU3RhdGUucGlwZWxpbmUgPSB0aGlzLnBpcGVsaW5lXG4gICAgICBpZiAoY2IpIHBpcGVUby5vbignZXJyb3InLCBub29wKSAvLyBXZSBhbHJlYWR5IGVycm9yIGhhbmRsZSB0aGlzIHNvIHN1cHJlc3MgY3Jhc2hlc1xuICAgICAgcGlwZVRvLm9uKCdmaW5pc2gnLCB0aGlzLnBpcGVsaW5lLmZpbmlzaGVkLmJpbmQodGhpcy5waXBlbGluZSkpIC8vIFRPRE86IGp1c3QgY2FsbCBmaW5pc2hlZCBmcm9tIHBpcGVUbyBpdHNlbGZcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb25lcnJvciA9IHRoaXMucGlwZWxpbmUuZG9uZS5iaW5kKHRoaXMucGlwZWxpbmUsIHBpcGVUbylcbiAgICAgIGNvbnN0IG9uY2xvc2UgPSB0aGlzLnBpcGVsaW5lLmRvbmUuYmluZCh0aGlzLnBpcGVsaW5lLCBwaXBlVG8sIG51bGwpIC8vIG9uY2xvc2UgaGFzIGEgd2VpcmQgYm9vbCBhcmdcbiAgICAgIHBpcGVUby5vbignZXJyb3InLCBvbmVycm9yKVxuICAgICAgcGlwZVRvLm9uKCdjbG9zZScsIG9uY2xvc2UpXG4gICAgICBwaXBlVG8ub24oJ2ZpbmlzaCcsIHRoaXMucGlwZWxpbmUuZmluaXNoZWQuYmluZCh0aGlzLnBpcGVsaW5lKSlcbiAgICB9XG5cbiAgICBwaXBlVG8ub24oJ2RyYWluJywgYWZ0ZXJEcmFpbi5iaW5kKHRoaXMpKVxuICAgIHRoaXMuc3RyZWFtLmVtaXQoJ3BpcGluZycsIHBpcGVUbylcbiAgICBwaXBlVG8uZW1pdCgncGlwZScsIHRoaXMuc3RyZWFtKVxuICB9XG5cbiAgcHVzaCAoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gMFxuICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSA9IChzdHJlYW0uX2R1cGxleFN0YXRlIHwgUkVBRF9FTkRJTkcpICYgUkVBRF9OT05fUFJJTUFSWV9BTkRfUFVTSEVEXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXAgIT09IG51bGwpIHtcbiAgICAgIGRhdGEgPSB0aGlzLm1hcChkYXRhKVxuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX1BVU0hFRFxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJlZCA8IHRoaXMuaGlnaFdhdGVyTWFya1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyZWQgKz0gdGhpcy5ieXRlTGVuZ3RoKGRhdGEpXG4gICAgdGhpcy5xdWV1ZS5wdXNoKGRhdGEpXG5cbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlID0gKHN0cmVhbS5fZHVwbGV4U3RhdGUgfCBSRUFEX1FVRVVFRCkgJiBSRUFEX1BVU0hFRFxuXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyZWQgPCB0aGlzLmhpZ2hXYXRlck1hcmtcbiAgfVxuXG4gIHNoaWZ0ICgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5xdWV1ZS5zaGlmdCgpXG5cbiAgICB0aGlzLmJ1ZmZlcmVkIC09IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgIGlmICh0aGlzLmJ1ZmZlcmVkID09PSAwKSB0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT1RfUVVFVUVEXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHVuc2hpZnQgKGRhdGEpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW3RoaXMubWFwICE9PSBudWxsID8gdGhpcy5tYXAoZGF0YSkgOiBkYXRhXVxuICAgIHdoaWxlICh0aGlzLmJ1ZmZlcmVkID4gMCkgcGVuZGluZy5wdXNoKHRoaXMuc2hpZnQoKSlcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBwZW5kaW5nW2ldXG4gICAgICB0aGlzLmJ1ZmZlcmVkICs9IHRoaXMuYnl0ZUxlbmd0aChkYXRhKVxuICAgICAgdGhpcy5xdWV1ZS5wdXNoKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHBlbmRpbmdbcGVuZGluZy5sZW5ndGggLSAxXSlcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1NUQVRVUykgPT09IFJFQURfUVVFVUVEKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5zaGlmdCgpXG4gICAgICBpZiAodGhpcy5waXBlVG8gIT09IG51bGwgJiYgdGhpcy5waXBlVG8ud3JpdGUoZGF0YSkgPT09IGZhbHNlKSBzdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfUElQRV9OT1RfRFJBSU5FRFxuICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9FTUlUX0RBVEEpICE9PSAwKSBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWRBaGVhZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9SRUFEX0FIRUFEXG4gICAgICB0aGlzLnVwZGF0ZU5leHRUaWNrKClcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZHJhaW4gKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG5cbiAgICB3aGlsZSAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1NUQVRVUykgPT09IFJFQURfUVVFVUVEICYmIChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9GTE9XSU5HKSAhPT0gMCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuc2hpZnQoKVxuICAgICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsICYmIHRoaXMucGlwZVRvLndyaXRlKGRhdGEpID09PSBmYWxzZSkgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX1BJUEVfTk9UX0RSQUlORURcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRU1JVF9EQVRBKSAhPT0gMCkgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSAoKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9VUERBVElOR1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5kcmFpbigpXG5cbiAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlcmVkIDwgdGhpcy5oaWdoV2F0ZXJNYXJrICYmIChzdHJlYW0uX2R1cGxleFN0YXRlICYgU0hPVUxEX05PVF9SRUFEKSA9PT0gUkVBRF9SRUFEX0FIRUFEKSB7XG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gUkVBRF9BQ1RJVkVfQU5EX05FRURTX1BVU0hcbiAgICAgICAgc3RyZWFtLl9yZWFkKHRoaXMuYWZ0ZXJSZWFkKVxuICAgICAgICB0aGlzLmRyYWluKClcbiAgICAgIH1cblxuICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9SRUFEQUJMRV9TVEFUVVMpID09PSBSRUFEX0VNSVRfUkVBREFCTEVfQU5EX1FVRVVFRCkge1xuICAgICAgICBzdHJlYW0uX2R1cGxleFN0YXRlIHw9IFJFQURfRU1JVFRFRF9SRUFEQUJMRVxuICAgICAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKVxuICAgICAgfVxuXG4gICAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1BSSU1BUllfQU5EX0FDVElWRSkgPT09IDApIHRoaXMudXBkYXRlTm9uUHJpbWFyeSgpXG4gICAgfSB3aGlsZSAodGhpcy5jb250aW51ZVVwZGF0ZSgpID09PSB0cnVlKVxuXG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PVF9VUERBVElOR1xuICB9XG5cbiAgdXBkYXRlTm9uUHJpbWFyeSAoKSB7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRU5ESU5HX1NUQVRVUykgPT09IFJFQURfRU5ESU5HKSB7XG4gICAgICBzdHJlYW0uX2R1cGxleFN0YXRlID0gKHN0cmVhbS5fZHVwbGV4U3RhdGUgfCBSRUFEX0RPTkUpICYgUkVBRF9OT1RfRU5ESU5HXG4gICAgICBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFVVE9fREVTVFJPWSkgPT09IERPTkUpIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gREVTVFJPWUlOR1xuICAgICAgaWYgKHRoaXMucGlwZVRvICE9PSBudWxsKSB0aGlzLnBpcGVUby5lbmQoKVxuICAgIH1cblxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lfU1RBVFVTKSA9PT0gREVTVFJPWUlORykge1xuICAgICAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgQUNUSVZFX09SX1RJQ0tJTkcpID09PSAwKSB7XG4gICAgICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gQUNUSVZFXG4gICAgICAgIHN0cmVhbS5fZGVzdHJveShhZnRlckRlc3Ryb3kuYmluZCh0aGlzKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIElTX09QRU5JTkcpID09PSBPUEVOSU5HKSB7XG4gICAgICBzdHJlYW0uX2R1cGxleFN0YXRlID0gKHN0cmVhbS5fZHVwbGV4U3RhdGUgfCBBQ1RJVkUpICYgTk9UX09QRU5JTkdcbiAgICAgIHN0cmVhbS5fb3BlbihhZnRlck9wZW4uYmluZCh0aGlzKSlcbiAgICB9XG4gIH1cblxuICBjb250aW51ZVVwZGF0ZSAoKSB7XG4gICAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX05FWFRfVElDSykgPT09IDApIHJldHVybiBmYWxzZVxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PVF9ORVhUX1RJQ0tcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdXBkYXRlQ2FsbGJhY2sgKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9VUERBVEVfU1lOQ19TVEFUVVMpID09PSBSRUFEX1BSSU1BUlkpIHRoaXMudXBkYXRlKClcbiAgICBlbHNlIHRoaXMudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgdXBkYXRlTmV4dFRpY2tJZk9wZW4gKCkge1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9ORVhUX1RJQ0tfT1JfT1BFTklORykgIT09IDApIHJldHVyblxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX05FWFRfVElDS1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9VUERBVElORykgPT09IDApIHFtdCh0aGlzLmFmdGVyVXBkYXRlTmV4dFRpY2spXG4gIH1cblxuICB1cGRhdGVOZXh0VGljayAoKSB7XG4gICAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX05FWFRfVElDSykgIT09IDApIHJldHVyblxuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX05FWFRfVElDS1xuICAgIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9VUERBVElORykgPT09IDApIHFtdCh0aGlzLmFmdGVyVXBkYXRlTmV4dFRpY2spXG4gIH1cbn1cblxuY2xhc3MgVHJhbnNmb3JtU3RhdGUge1xuICBjb25zdHJ1Y3RvciAoc3RyZWFtKSB7XG4gICAgdGhpcy5kYXRhID0gbnVsbFxuICAgIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBhZnRlclRyYW5zZm9ybS5iaW5kKHN0cmVhbSlcbiAgICB0aGlzLmFmdGVyRmluYWwgPSBudWxsXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmUge1xuICBjb25zdHJ1Y3RvciAoc3JjLCBkc3QsIGNiKSB7XG4gICAgdGhpcy5mcm9tID0gc3JjXG4gICAgdGhpcy50byA9IGRzdFxuICAgIHRoaXMuYWZ0ZXJQaXBlID0gY2JcbiAgICB0aGlzLmVycm9yID0gbnVsbFxuICAgIHRoaXMucGlwZVRvRmluaXNoZWQgPSBmYWxzZVxuICB9XG5cbiAgZmluaXNoZWQgKCkge1xuICAgIHRoaXMucGlwZVRvRmluaXNoZWQgPSB0cnVlXG4gIH1cblxuICBkb25lIChzdHJlYW0sIGVycikge1xuICAgIGlmIChlcnIpIHRoaXMuZXJyb3IgPSBlcnJcblxuICAgIGlmIChzdHJlYW0gPT09IHRoaXMudG8pIHtcbiAgICAgIHRoaXMudG8gPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLmZyb20gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCh0aGlzLmZyb20uX2R1cGxleFN0YXRlICYgUkVBRF9ET05FKSA9PT0gMCB8fCAhdGhpcy5waXBlVG9GaW5pc2hlZCkge1xuICAgICAgICAgIHRoaXMuZnJvbS5kZXN0cm95KHRoaXMuZXJyb3IgfHwgbmV3IEVycm9yKCdXcml0YWJsZSBzdHJlYW0gY2xvc2VkIHByZW1hdHVyZWx5JykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbSA9PT0gdGhpcy5mcm9tKSB7XG4gICAgICB0aGlzLmZyb20gPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLnRvICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRE9ORSkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLnRvLmRlc3Ryb3kodGhpcy5lcnJvciB8fCBuZXcgRXJyb3IoJ1JlYWRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGVuZGluZycpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFmdGVyUGlwZSAhPT0gbnVsbCkgdGhpcy5hZnRlclBpcGUodGhpcy5lcnJvcilcbiAgICB0aGlzLnRvID0gdGhpcy5mcm9tID0gdGhpcy5hZnRlclBpcGUgPSBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJEcmFpbiAoKSB7XG4gIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX1BJUEVfRFJBSU5FRFxuICB0aGlzLnVwZGF0ZUNhbGxiYWNrKClcbn1cblxuZnVuY3Rpb24gYWZ0ZXJGaW5hbCAoZXJyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtXG4gIGlmIChlcnIpIHN0cmVhbS5kZXN0cm95KGVycilcbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWV9TVEFUVVMpID09PSAwKSB7XG4gICAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9ET05FXG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpXG4gIH1cbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgQVVUT19ERVNUUk9ZKSA9PT0gRE9ORSkge1xuICAgIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gREVTVFJPWUlOR1xuICB9XG5cbiAgc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfRklOSVNISU5HXG5cbiAgLy8gbm8gbmVlZCB0byB3YWl0IHRoZSBleHRyYSB0aWNrIGhlcmUsIHNvIHdlIHNob3J0IGNpcmN1aXQgdGhhdFxuICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9VUERBVElORykgPT09IDApIHRoaXMudXBkYXRlKClcbiAgZWxzZSB0aGlzLnVwZGF0ZU5leHRUaWNrKClcbn1cblxuZnVuY3Rpb24gYWZ0ZXJEZXN0cm95IChlcnIpIHtcbiAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICBpZiAoIWVyciAmJiB0aGlzLmVycm9yICE9PSBTVFJFQU1fREVTVFJPWUVEKSBlcnIgPSB0aGlzLmVycm9yXG4gIGlmIChlcnIpIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBERVNUUk9ZRURcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcblxuICBjb25zdCBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuXG4gIGlmIChycyAhPT0gbnVsbCAmJiBycy5waXBlbGluZSAhPT0gbnVsbCkgcnMucGlwZWxpbmUuZG9uZShzdHJlYW0sIGVycilcblxuICBpZiAod3MgIT09IG51bGwpIHtcbiAgICB3aGlsZSAod3MuZHJhaW5zICE9PSBudWxsICYmIHdzLmRyYWlucy5sZW5ndGggPiAwKSB3cy5kcmFpbnMuc2hpZnQoKS5yZXNvbHZlKGZhbHNlKVxuICAgIGlmICh3cy5waXBlbGluZSAhPT0gbnVsbCkgd3MucGlwZWxpbmUuZG9uZShzdHJlYW0sIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlIChlcnIpIHtcbiAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICBpZiAoZXJyKSBzdHJlYW0uZGVzdHJveShlcnIpXG4gIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX0FDVElWRVxuXG4gIGlmICh0aGlzLmRyYWlucyAhPT0gbnVsbCkgdGlja0RyYWlucyh0aGlzLmRyYWlucylcblxuICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9EUkFJTl9TVEFUVVMpID09PSBXUklURV9VTkRSQUlORUQpIHtcbiAgICBzdHJlYW0uX2R1cGxleFN0YXRlICY9IFdSSVRFX0RSQUlORURcbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9FTUlUX0RSQUlOKSA9PT0gV1JJVEVfRU1JVF9EUkFJTikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2RyYWluJylcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZUNhbGxiYWNrKClcbn1cblxuZnVuY3Rpb24gYWZ0ZXJSZWFkIChlcnIpIHtcbiAgaWYgKGVycikgdGhpcy5zdHJlYW0uZGVzdHJveShlcnIpXG4gIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PVF9BQ1RJVkVcbiAgaWYgKHRoaXMucmVhZEFoZWFkID09PSBmYWxzZSAmJiAodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgUkVBRF9SRVNVTUVEKSA9PT0gMCkgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFJFQURfTk9fUkVBRF9BSEVBRFxuICB0aGlzLnVwZGF0ZUNhbGxiYWNrKClcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVhZE5UICgpIHtcbiAgaWYgKCh0aGlzLnN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1VQREFUSU5HKSA9PT0gMCkge1xuICAgIHRoaXMuc3RyZWFtLl9kdXBsZXhTdGF0ZSAmPSBSRUFEX05PVF9ORVhUX1RJQ0tcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JpdGVOVCAoKSB7XG4gIGlmICgodGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICYgV1JJVEVfVVBEQVRJTkcpID09PSAwKSB7XG4gICAgdGhpcy5zdHJlYW0uX2R1cGxleFN0YXRlICY9IFdSSVRFX05PVF9ORVhUX1RJQ0tcbiAgICB0aGlzLnVwZGF0ZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gdGlja0RyYWlucyAoZHJhaW5zKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZHJhaW5zLndyaXRlcyBhcmUgbW9ub3RvbmljLCBzbyBpZiBvbmUgaXMgMCBpdHMgYWx3YXlzIHRoZSBmaXJzdCBvbmVcbiAgICBpZiAoLS1kcmFpbnNbaV0ud3JpdGVzID09PSAwKSB7XG4gICAgICBkcmFpbnMuc2hpZnQoKS5yZXNvbHZlKHRydWUpXG4gICAgICBpLS1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJPcGVuIChlcnIpIHtcbiAgY29uc3Qgc3RyZWFtID0gdGhpcy5zdHJlYW1cblxuICBpZiAoZXJyKSBzdHJlYW0uZGVzdHJveShlcnIpXG5cbiAgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWUlORykgPT09IDApIHtcbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBSRUFEX1BSSU1BUllfU1RBVFVTKSA9PT0gMCkgc3RyZWFtLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX1BSSU1BUllcbiAgICBpZiAoKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBXUklURV9QUklNQVJZX1NUQVRVUykgPT09IDApIHN0cmVhbS5fZHVwbGV4U3RhdGUgfD0gV1JJVEVfUFJJTUFSWVxuICAgIHN0cmVhbS5lbWl0KCdvcGVuJylcbiAgfVxuXG4gIHN0cmVhbS5fZHVwbGV4U3RhdGUgJj0gTk9UX0FDVElWRVxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUudXBkYXRlQ2FsbGJhY2soKVxuICB9XG5cbiAgaWYgKHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS51cGRhdGVDYWxsYmFjaygpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0gKGVyciwgZGF0YSkge1xuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGwpIHRoaXMucHVzaChkYXRhKVxuICB0aGlzLl93cml0YWJsZVN0YXRlLmFmdGVyV3JpdGUoZXJyKVxufVxuXG5mdW5jdGlvbiBuZXdMaXN0ZW5lciAobmFtZSkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuYW1lID09PSAnZGF0YScpIHtcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IChSRUFEX0VNSVRfREFUQSB8IFJFQURfUkVTVU1FRF9SRUFEX0FIRUFEKVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgfVxuICAgIGlmIChuYW1lID09PSAncmVhZGFibGUnKSB7XG4gICAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX0VNSVRfUkVBREFCTEVcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5hbWUgPT09ICdkcmFpbicpIHtcbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IFdSSVRFX0VNSVRfRFJBSU5cbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBTdHJlYW0gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX2R1cGxleFN0YXRlID0gMFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBudWxsXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG51bGxcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAob3B0cy5vcGVuKSB0aGlzLl9vcGVuID0gb3B0cy5vcGVuXG4gICAgICBpZiAob3B0cy5kZXN0cm95KSB0aGlzLl9kZXN0cm95ID0gb3B0cy5kZXN0cm95XG4gICAgICBpZiAob3B0cy5wcmVkZXN0cm95KSB0aGlzLl9wcmVkZXN0cm95ID0gb3B0cy5wcmVkZXN0cm95XG4gICAgICBpZiAob3B0cy5zaWduYWwpIHtcbiAgICAgICAgb3B0cy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydC5iaW5kKHRoaXMpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub24oJ25ld0xpc3RlbmVyJywgbmV3TGlzdGVuZXIpXG4gIH1cblxuICBfb3BlbiAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9wcmVkZXN0cm95ICgpIHtcbiAgICAvLyBkb2VzIG5vdGhpbmdcbiAgfVxuXG4gIGdldCByZWFkYWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgIT09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXQgd3JpdGFibGUgKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICE9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9kdXBsZXhTdGF0ZSAmIERFU1RST1lFRCkgIT09IDBcbiAgfVxuXG4gIGdldCBkZXN0cm95aW5nICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2R1cGxleFN0YXRlICYgREVTVFJPWV9TVEFUVVMpICE9PSAwXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBpZiAoKHRoaXMuX2R1cGxleFN0YXRlICYgREVTVFJPWV9TVEFUVVMpID09PSAwKSB7XG4gICAgICBpZiAoIWVycikgZXJyID0gU1RSRUFNX0RFU1RST1lFRFxuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgPSAodGhpcy5fZHVwbGV4U3RhdGUgfCBERVNUUk9ZSU5HKSAmIE5PTl9QUklNQVJZXG5cbiAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyayA9IDBcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvciA9IGVyclxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrID0gMFxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yID0gZXJyXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IFBSRURFU1RST1lJTkdcbiAgICAgIHRoaXMuX3ByZWRlc3Ryb3koKVxuICAgICAgdGhpcy5fZHVwbGV4U3RhdGUgJj0gTk9UX1BSRURFU1RST1lJTkdcblxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgIT09IG51bGwpIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgIT09IG51bGwpIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZWFkYWJsZSBleHRlbmRzIFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IE9QRU5JTkcgfCBXUklURV9ET05FIHwgUkVBRF9SRUFEX0FIRUFEXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKHRoaXMsIG9wdHMpXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZEFoZWFkID09PSBmYWxzZSkgdGhpcy5fZHVwbGV4U3RhdGUgJj0gUkVBRF9OT19SRUFEX0FIRUFEXG4gICAgICBpZiAob3B0cy5yZWFkKSB0aGlzLl9yZWFkID0gb3B0cy5yZWFkXG4gICAgICBpZiAob3B0cy5lYWdlck9wZW4pIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgICAgaWYgKG9wdHMuZW5jb2RpbmcpIHRoaXMuc2V0RW5jb2Rpbmcob3B0cy5lbmNvZGluZylcbiAgICB9XG4gIH1cblxuICBzZXRFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBkZWMgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcpXG4gICAgY29uc3QgbWFwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5tYXAgfHwgZWNob1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUubWFwID0gbWFwT3JTa2lwXG4gICAgcmV0dXJuIHRoaXNcblxuICAgIGZ1bmN0aW9uIG1hcE9yU2tpcCAoZGF0YSkge1xuICAgICAgY29uc3QgbmV4dCA9IGRlYy5wdXNoKGRhdGEpXG4gICAgICByZXR1cm4gbmV4dCA9PT0gJycgJiYgKGRhdGEuYnl0ZUxlbmd0aCAhPT0gMCB8fCBkZWMucmVtYWluaW5nID4gMCkgPyBudWxsIDogbWFwKG5leHQpXG4gICAgfVxuICB9XG5cbiAgX3JlYWQgKGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIGNiKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5waXBlKGRlc3QsIGNiKVxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICByZWFkICgpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkKClcbiAgfVxuXG4gIHB1c2ggKGRhdGEpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrSWZPcGVuKClcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5wdXNoKGRhdGEpXG4gIH1cblxuICB1bnNoaWZ0IChkYXRhKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS51cGRhdGVOZXh0VGlja0lmT3BlbigpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUudW5zaGlmdChkYXRhKVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBSRUFEX1JFU1VNRURfUkVBRF9BSEVBRFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgJj0gKHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZEFoZWFkID09PSBmYWxzZSA/IFJFQURfUEFVU0VEX05PX1JFQURfQUhFQUQgOiBSRUFEX1BBVVNFRClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIF9mcm9tQXN5bmNJdGVyYXRvciAoaXRlLCBvcHRzKSB7XG4gICAgbGV0IGRlc3Ryb3lcblxuICAgIGNvbnN0IHJzID0gbmV3IFJlYWRhYmxlKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZWFkIChjYikge1xuICAgICAgICBpdGUubmV4dCgpLnRoZW4ocHVzaCkudGhlbihjYi5iaW5kKG51bGwsIG51bGwpKS5jYXRjaChjYilcbiAgICAgIH0sXG4gICAgICBwcmVkZXN0cm95ICgpIHtcbiAgICAgICAgZGVzdHJveSA9IGl0ZS5yZXR1cm4oKVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3kgKGNiKSB7XG4gICAgICAgIGlmICghZGVzdHJveSkgcmV0dXJuIGNiKG51bGwpXG4gICAgICAgIGRlc3Ryb3kudGhlbihjYi5iaW5kKG51bGwsIG51bGwpKS5jYXRjaChjYilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHJzXG5cbiAgICBmdW5jdGlvbiBwdXNoIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5kb25lKSBycy5wdXNoKG51bGwpXG4gICAgICBlbHNlIHJzLnB1c2goZGF0YS52YWx1ZSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZnJvbSAoZGF0YSwgb3B0cykge1xuICAgIGlmIChpc1JlYWRTdHJlYW14KGRhdGEpKSByZXR1cm4gZGF0YVxuICAgIGlmIChkYXRhW2FzeW5jSXRlcmF0b3JdKSByZXR1cm4gdGhpcy5fZnJvbUFzeW5jSXRlcmF0b3IoZGF0YVthc3luY0l0ZXJhdG9yXSgpLCBvcHRzKVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgZGF0YSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IFtdIDogW2RhdGFdXG5cbiAgICBsZXQgaSA9IDBcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZWFkIChjYikge1xuICAgICAgICB0aGlzLnB1c2goaSA9PT0gZGF0YS5sZW5ndGggPyBudWxsIDogZGF0YVtpKytdKVxuICAgICAgICBjYihudWxsKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgaXNCYWNrcHJlc3N1cmVkIChycykge1xuICAgIHJldHVybiAocnMuX2R1cGxleFN0YXRlICYgUkVBRF9CQUNLUFJFU1NVUkVfU1RBVFVTKSAhPT0gMCB8fCBycy5fcmVhZGFibGVTdGF0ZS5idWZmZXJlZCA+PSBycy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gIH1cblxuICBzdGF0aWMgaXNQYXVzZWQgKHJzKSB7XG4gICAgcmV0dXJuIChycy5fZHVwbGV4U3RhdGUgJiBSRUFEX1JFU1VNRUQpID09PSAwXG4gIH1cblxuICBbYXN5bmNJdGVyYXRvcl0gKCkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXNcblxuICAgIGxldCBlcnJvciA9IG51bGxcbiAgICBsZXQgcHJvbWlzZVJlc29sdmUgPSBudWxsXG4gICAgbGV0IHByb21pc2VSZWplY3QgPSBudWxsXG5cbiAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHsgZXJyb3IgPSBlcnIgfSlcbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gICAgdGhpcy5vbignY2xvc2UnLCBvbmNsb3NlKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFthc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgbmV4dCAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlXG4gICAgICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdFxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBzdHJlYW0ucmVhZCgpXG4gICAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIG9uZGF0YShkYXRhKVxuICAgICAgICAgIGVsc2UgaWYgKChzdHJlYW0uX2R1cGxleFN0YXRlICYgREVTVFJPWUVEKSAhPT0gMCkgb25kYXRhKG51bGwpXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmV0dXJuICgpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Ryb3kobnVsbClcbiAgICAgIH0sXG4gICAgICB0aHJvdyAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkZXN0cm95KGVycilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbnJlYWRhYmxlICgpIHtcbiAgICAgIGlmIChwcm9taXNlUmVzb2x2ZSAhPT0gbnVsbCkgb25kYXRhKHN0cmVhbS5yZWFkKCkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgICBpZiAocHJvbWlzZVJlc29sdmUgIT09IG51bGwpIG9uZGF0YShudWxsKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uZGF0YSAoZGF0YSkge1xuICAgICAgaWYgKHByb21pc2VSZWplY3QgPT09IG51bGwpIHJldHVyblxuICAgICAgaWYgKGVycm9yKSBwcm9taXNlUmVqZWN0KGVycm9yKVxuICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gbnVsbCAmJiAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIFJFQURfRE9ORSkgPT09IDApIHByb21pc2VSZWplY3QoU1RSRUFNX0RFU1RST1lFRClcbiAgICAgIGVsc2UgcHJvbWlzZVJlc29sdmUoeyB2YWx1ZTogZGF0YSwgZG9uZTogZGF0YSA9PT0gbnVsbCB9KVxuICAgICAgcHJvbWlzZVJlamVjdCA9IHByb21pc2VSZXNvbHZlID0gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3kgKGVycikge1xuICAgICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBERVNUUk9ZRUQpIHJldHVybiByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KVxuICAgICAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycilcbiAgICAgICAgICBlbHNlIHJlc29sdmUoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBXcml0YWJsZSBleHRlbmRzIFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IE9QRU5JTkcgfCBSRUFEX0RPTkVcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUodGhpcywgb3B0cylcblxuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAob3B0cy53cml0ZXYpIHRoaXMuX3dyaXRldiA9IG9wdHMud3JpdGV2XG4gICAgICBpZiAob3B0cy53cml0ZSkgdGhpcy5fd3JpdGUgPSBvcHRzLndyaXRlXG4gICAgICBpZiAob3B0cy5maW5hbCkgdGhpcy5fZmluYWwgPSBvcHRzLmZpbmFsXG4gICAgICBpZiAob3B0cy5lYWdlck9wZW4pIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICAgIH1cbiAgfVxuXG4gIGNvcmsgKCkge1xuICAgIHRoaXMuX2R1cGxleFN0YXRlIHw9IFdSSVRFX0NPUktFRFxuICB9XG5cbiAgdW5jb3JrICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSAmPSBXUklURV9OT1RfQ09SS0VEXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS51cGRhdGVOZXh0VGljaygpXG4gIH1cblxuICBfd3JpdGV2IChiYXRjaCwgY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX3dyaXRlIChkYXRhLCBjYikge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuYXV0b0JhdGNoKGRhdGEsIGNiKVxuICB9XG5cbiAgX2ZpbmFsIChjYikge1xuICAgIGNiKG51bGwpXG4gIH1cblxuICBzdGF0aWMgaXNCYWNrcHJlc3N1cmVkICh3cykge1xuICAgIHJldHVybiAod3MuX2R1cGxleFN0YXRlICYgV1JJVEVfQkFDS1BSRVNTVVJFX1NUQVRVUykgIT09IDBcbiAgfVxuXG4gIHN0YXRpYyBkcmFpbmVkICh3cykge1xuICAgIGlmICh3cy5kZXN0cm95ZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG4gICAgY29uc3Qgc3RhdGUgPSB3cy5fd3JpdGFibGVTdGF0ZVxuICAgIGNvbnN0IHBlbmRpbmcgPSAoaXNXcml0ZXYod3MpID8gTWF0aC5taW4oMSwgc3RhdGUucXVldWUubGVuZ3RoKSA6IHN0YXRlLnF1ZXVlLmxlbmd0aClcbiAgICBjb25zdCB3cml0ZXMgPSBwZW5kaW5nICsgKCh3cy5fZHVwbGV4U3RhdGUgJiBXUklURV9XUklUSU5HKSA/IDEgOiAwKVxuICAgIGlmICh3cml0ZXMgPT09IDApIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSlcbiAgICBpZiAoc3RhdGUuZHJhaW5zID09PSBudWxsKSBzdGF0ZS5kcmFpbnMgPSBbXVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc3RhdGUuZHJhaW5zLnB1c2goeyB3cml0ZXMsIHJlc29sdmUgfSlcbiAgICB9KVxuICB9XG5cbiAgd3JpdGUgKGRhdGEpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5wdXNoKGRhdGEpXG4gIH1cblxuICBlbmQgKGRhdGEpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZChkYXRhKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuY2xhc3MgRHVwbGV4IGV4dGVuZHMgUmVhZGFibGUgeyAvLyBhbmQgV3JpdGFibGVcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgPSBPUEVOSU5HIHwgKHRoaXMuX2R1cGxleFN0YXRlICYgUkVBRF9SRUFEX0FIRUFEKVxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZSh0aGlzLCBvcHRzKVxuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmIChvcHRzLndyaXRldikgdGhpcy5fd3JpdGV2ID0gb3B0cy53cml0ZXZcbiAgICAgIGlmIChvcHRzLndyaXRlKSB0aGlzLl93cml0ZSA9IG9wdHMud3JpdGVcbiAgICAgIGlmIChvcHRzLmZpbmFsKSB0aGlzLl9maW5hbCA9IG9wdHMuZmluYWxcbiAgICB9XG4gIH1cblxuICBjb3JrICgpIHtcbiAgICB0aGlzLl9kdXBsZXhTdGF0ZSB8PSBXUklURV9DT1JLRURcbiAgfVxuXG4gIHVuY29yayAoKSB7XG4gICAgdGhpcy5fZHVwbGV4U3RhdGUgJj0gV1JJVEVfTk9UX0NPUktFRFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUudXBkYXRlTmV4dFRpY2soKVxuICB9XG5cbiAgX3dyaXRldiAoYmF0Y2gsIGNiKSB7XG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF93cml0ZSAoZGF0YSwgY2IpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmF1dG9CYXRjaChkYXRhLCBjYilcbiAgfVxuXG4gIF9maW5hbCAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgd3JpdGUgKGRhdGEpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5wdXNoKGRhdGEpXG4gIH1cblxuICBlbmQgKGRhdGEpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnVwZGF0ZU5leHRUaWNrKClcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZChkYXRhKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKG9wdHMudHJhbnNmb3JtKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRzLnRyYW5zZm9ybVxuICAgICAgaWYgKG9wdHMuZmx1c2gpIHRoaXMuX2ZsdXNoID0gb3B0cy5mbHVzaFxuICAgIH1cbiAgfVxuXG4gIF93cml0ZSAoZGF0YSwgY2IpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXJlZCA+PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGEgPSBkYXRhXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybShkYXRhLCB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlclRyYW5zZm9ybSlcbiAgICB9XG4gIH1cblxuICBfcmVhZCAoY2IpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNmb3JtU3RhdGUuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGFcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmRhdGEgPSBudWxsXG4gICAgICBjYihudWxsKVxuICAgICAgdGhpcy5fdHJhbnNmb3JtKGRhdGEsIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmFmdGVyVHJhbnNmb3JtKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIHN1cGVyLmRlc3Ryb3koZXJyKVxuICAgIGlmICh0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5kYXRhID0gbnVsbFxuICAgICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUuYWZ0ZXJUcmFuc2Zvcm0oKVxuICAgIH1cbiAgfVxuXG4gIF90cmFuc2Zvcm0gKGRhdGEsIGNiKSB7XG4gICAgY2IobnVsbCwgZGF0YSlcbiAgfVxuXG4gIF9mbHVzaCAoY2IpIHtcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX2ZpbmFsIChjYikge1xuICAgIHRoaXMuX3RyYW5zZm9ybVN0YXRlLmFmdGVyRmluYWwgPSBjYlxuICAgIHRoaXMuX2ZsdXNoKHRyYW5zZm9ybUFmdGVyRmx1c2guYmluZCh0aGlzKSlcbiAgfVxufVxuXG5jbGFzcyBQYXNzVGhyb3VnaCBleHRlbmRzIFRyYW5zZm9ybSB7fVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1BZnRlckZsdXNoIChlcnIsIGRhdGEpIHtcbiAgY29uc3QgY2IgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5hZnRlckZpbmFsXG4gIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgdGhpcy5wdXNoKGRhdGEpXG4gIHRoaXMucHVzaChudWxsKVxuICBjYihudWxsKVxufVxuXG5mdW5jdGlvbiBwaXBlbGluZVByb21pc2UgKC4uLnN0cmVhbXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXR1cm4gcGlwZWxpbmUoLi4uc3RyZWFtcywgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBwaXBlbGluZSAoc3RyZWFtLCAuLi5zdHJlYW1zKSB7XG4gIGNvbnN0IGFsbCA9IEFycmF5LmlzQXJyYXkoc3RyZWFtKSA/IFsuLi5zdHJlYW0sIC4uLnN0cmVhbXNdIDogW3N0cmVhbSwgLi4uc3RyZWFtc11cbiAgY29uc3QgZG9uZSA9IChhbGwubGVuZ3RoICYmIHR5cGVvZiBhbGxbYWxsLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSA/IGFsbC5wb3AoKSA6IG51bGxcblxuICBpZiAoYWxsLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcignUGlwZWxpbmUgcmVxdWlyZXMgYXQgbGVhc3QgMiBzdHJlYW1zJylcblxuICBsZXQgc3JjID0gYWxsWzBdXG4gIGxldCBkZXN0ID0gbnVsbFxuICBsZXQgZXJyb3IgPSBudWxsXG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0ID0gYWxsW2ldXG5cbiAgICBpZiAoaXNTdHJlYW14KHNyYykpIHtcbiAgICAgIHNyYy5waXBlKGRlc3QsIG9uZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ySGFuZGxlKHNyYywgdHJ1ZSwgaSA+IDEsIG9uZXJyb3IpXG4gICAgICBzcmMucGlwZShkZXN0KVxuICAgIH1cblxuICAgIHNyYyA9IGRlc3RcbiAgfVxuXG4gIGlmIChkb25lKSB7XG4gICAgbGV0IGZpbiA9IGZhbHNlXG5cbiAgICBjb25zdCBhdXRvRGVzdHJveSA9IGlzU3RyZWFteChkZXN0KSB8fCAhIShkZXN0Ll93cml0YWJsZVN0YXRlICYmIGRlc3QuX3dyaXRhYmxlU3RhdGUuYXV0b0Rlc3Ryb3kpXG5cbiAgICBkZXN0Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnJvciA9PT0gbnVsbCkgZXJyb3IgPSBlcnJcbiAgICB9KVxuXG4gICAgZGVzdC5vbignZmluaXNoJywgKCkgPT4ge1xuICAgICAgZmluID0gdHJ1ZVxuICAgICAgaWYgKCFhdXRvRGVzdHJveSkgZG9uZShlcnJvcilcbiAgICB9KVxuXG4gICAgaWYgKGF1dG9EZXN0cm95KSB7XG4gICAgICBkZXN0Lm9uKCdjbG9zZScsICgpID0+IGRvbmUoZXJyb3IgfHwgKGZpbiA/IG51bGwgOiBQUkVNQVRVUkVfQ0xPU0UpKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVzdFxuXG4gIGZ1bmN0aW9uIGVycm9ySGFuZGxlIChzLCByZCwgd3IsIG9uZXJyb3IpIHtcbiAgICBzLm9uKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgcy5vbignY2xvc2UnLCBvbmNsb3NlKVxuXG4gICAgZnVuY3Rpb24gb25jbG9zZSAoKSB7XG4gICAgICBpZiAocmQgJiYgcy5fcmVhZGFibGVTdGF0ZSAmJiAhcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuIG9uZXJyb3IoUFJFTUFUVVJFX0NMT1NFKVxuICAgICAgaWYgKHdyICYmIHMuX3dyaXRhYmxlU3RhdGUgJiYgIXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybiBvbmVycm9yKFBSRU1BVFVSRV9DTE9TRSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICBpZiAoIWVyciB8fCBlcnJvcikgcmV0dXJuXG4gICAgZXJyb3IgPSBlcnJcblxuICAgIGZvciAoY29uc3QgcyBvZiBhbGwpIHtcbiAgICAgIHMuZGVzdHJveShlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVjaG8gKHMpIHtcbiAgcmV0dXJuIHNcbn1cblxuZnVuY3Rpb24gaXNTdHJlYW0gKHN0cmVhbSkge1xuICByZXR1cm4gISFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgISFzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbn1cblxuZnVuY3Rpb24gaXNTdHJlYW14IChzdHJlYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHJlYW0uX2R1cGxleFN0YXRlID09PSAnbnVtYmVyJyAmJiBpc1N0cmVhbShzdHJlYW0pXG59XG5cbmZ1bmN0aW9uIGlzRW5kZWQgKHN0cmVhbSkge1xuICByZXR1cm4gISFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkXG59XG5cbmZ1bmN0aW9uIGlzRmluaXNoZWQgKHN0cmVhbSkge1xuICByZXR1cm4gISFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkXG59XG5cbmZ1bmN0aW9uIGdldFN0cmVhbUVycm9yIChzdHJlYW0sIG9wdHMgPSB7fSkge1xuICBjb25zdCBlcnIgPSAoc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lcnJvcikgfHwgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3IpXG5cbiAgLy8gYXZvaWQgaW1wbGljaXQgZXJyb3JzIGJ5IGRlZmF1bHRcbiAgcmV0dXJuICghb3B0cy5hbGwgJiYgZXJyID09PSBTVFJFQU1fREVTVFJPWUVEKSA/IG51bGwgOiBlcnJcbn1cblxuZnVuY3Rpb24gaXNSZWFkU3RyZWFteCAoc3RyZWFtKSB7XG4gIHJldHVybiBpc1N0cmVhbXgoc3RyZWFtKSAmJiBzdHJlYW0ucmVhZGFibGVcbn1cblxuZnVuY3Rpb24gaXNEaXN0dXJiZWQgKHN0cmVhbSkge1xuICByZXR1cm4gKHN0cmVhbS5fZHVwbGV4U3RhdGUgJiBPUEVOSU5HKSAhPT0gT1BFTklORyB8fCAoc3RyZWFtLl9kdXBsZXhTdGF0ZSAmIEFDVElWRV9PUl9USUNLSU5HKSAhPT0gMFxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkgKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmIHR5cGVvZiBkYXRhLmJ5dGVMZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRCeXRlTGVuZ3RoIChkYXRhKSB7XG4gIHJldHVybiBpc1R5cGVkQXJyYXkoZGF0YSkgPyBkYXRhLmJ5dGVMZW5ndGggOiAxMDI0XG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gYWJvcnQgKCkge1xuICB0aGlzLmRlc3Ryb3kobmV3IEVycm9yKCdTdHJlYW0gYWJvcnRlZC4nKSlcbn1cblxuZnVuY3Rpb24gaXNXcml0ZXYgKHMpIHtcbiAgcmV0dXJuIHMuX3dyaXRldiAhPT0gV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgJiYgcy5fd3JpdGV2ICE9PSBEdXBsZXgucHJvdG90eXBlLl93cml0ZXZcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBpcGVsaW5lLFxuICBwaXBlbGluZVByb21pc2UsXG4gIGlzU3RyZWFtLFxuICBpc1N0cmVhbXgsXG4gIGlzRW5kZWQsXG4gIGlzRmluaXNoZWQsXG4gIGlzRGlzdHVyYmVkLFxuICBnZXRTdHJlYW1FcnJvcixcbiAgU3RyZWFtLFxuICBXcml0YWJsZSxcbiAgUmVhZGFibGUsXG4gIER1cGxleCxcbiAgVHJhbnNmb3JtLFxuICAvLyBFeHBvcnQgUGFzc1Rocm91Z2ggZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzIGNvcmUncyBzdHJlYW0gbW9kdWxlXG4gIFBhc3NUaHJvdWdoXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/streamx/index.js\n");

/***/ })

};
;